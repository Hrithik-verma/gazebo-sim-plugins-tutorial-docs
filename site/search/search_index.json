{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<pre><code>\ud83d\ude80 Lets Make Gazebo Sim Plugin Easy\n</code></pre> <p>   Motivation  As a beginer I personally find gazebo plugin to be very hard. In 2022,I made a bunch of tutorial for gazebo classic similary will do for gazebo sim. I always thought:</p> <ul> <li>what has changed from gazebo classic to sim?</li> <li>how gazebo plugin internally works?</li> <li>what is ECS? what are entity/components?</li> <li>where/how to read gazebo sim doc &amp; find useful info</li> <li>how to know which function to use?</li> </ul> <p>Finally, I'm here to answer all what where &amp; why. I feel so happy that I can share it with the world. Though this tutorials we decode all the secrets \ud83e\udd2b. We will learn every line of code in detail\ud83d\ude0d. </p>  \"Difficult part of gazebo plugin is not logic building rather how, when &amp; what function, msg, class &amp; Components(ECS) to use to code it. \"  <p>   Prerequisites  These are certain thing you need to know even before watching these tutorial series like <code>ros2</code>, basic of <code>gazebo sim</code>, <code>c++17</code> etc. Some good reference are:</p> <ol> <li> <p>OOPS in C++ At least some know of class, inheritance,  constructor,  virtual function</p> </li> <li> <p>Smart Pointers As we advance you will see will see that gazebo uses smart pointer a lot to point to classes &amp; function</p> </li> <li> <p>Entity Component System (ECS) ECS is the building block of gazebo sim &amp; ecs has be used in game engine for a long time now. Its better if you have some basic understanding of it.</p> </li> </ol> <p>A recommendation to download Visual Studio Code </p>"},{"location":"common-code-system-plugin/","title":"Common Used System Plugin API","text":"<p>important part in api doc:     - gz::sim     - gz::sim::EntityComponentManager     - gz::sim::components</p>"},{"location":"common-code-system-plugin/#understand-component","title":"Understand Component","text":"<pre><code>using X = Component&lt;DataType, class Tag&gt;;\n\n//        or \n\nusing X = Component&lt;DataType, class Tag, Serializer&gt;;\n</code></pre> <p>to access component: <code>components::X</code> , <code>X</code> is the component Name  Datatype: data type of that component  Serializer: use for data transfer (not so important) </p> <p></p> <p></p> <p></p> <p>access:  - <code>components::Name</code> - <code>components::LinearVelocity</code> - <code>components::Model</code></p> <p> </p>"},{"location":"common-code-system-plugin/#system-plugin-steps","title":"System Plugin Steps","text":""},{"location":"common-code-system-plugin/#1-find-the-entity","title":"1. Find The Entity","text":"<p>We will take help of components to find entity integer value like:</p> <ul> <li>has <code>Name</code> component of value <code>xyz</code></li> <li>has both <code>Entity</code> and <code>Name</code> components</li> </ul> a. plugin is directly attached to entity       in world file .sdf     <pre><code> &lt;model&gt;\n    ...\n\n    &lt;plugin&gt;..... &lt;/plugin&gt;   \n &lt;/model&gt;\n</code></pre>      code      <pre><code> void MoveModel::Configure(const Entity &amp;_entity, const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                    EntityComponentManager &amp;_ecm,\n                    EventManager &amp;/*_eventMgr*/){\n        // _entity --&gt; is the entity of model\n        entity = _entity;\n}\n</code></pre> b. search the entity by its name <pre><code>   // find the entity (int value) which has Name Component with value as \"xyz\"\n   targetEntity = _ecm.EntityByComponents(components::Name(\"xyz\"));\n</code></pre> <pre><code>auto entityOpt = _ecm.EntityByName(\"abc\");\nentity = entityOpt.value()\n</code></pre> c. find multiple entity <pre><code>  //check for such components which has Light, Name components\n  _ecm.Each&lt;components::Light, components::Name&gt;(\n    [&amp;](const Entity &amp;_entity,\n        const components::Light *,\n        const components::Name *_name) -&gt; bool\n    {\n      this-&gt;lightEntites.push_back(_entity);\n      // gzmsg &lt;&lt; \"Found light: \" &lt;&lt; _name-&gt;Data()\n      //       &lt;&lt; \" (entity \" &lt;&lt; _entity &lt;&lt; \")\\n\";\n      return true;\n    });\n</code></pre>"},{"location":"common-code-system-plugin/#2-readwrite-on-the-component-value","title":"2. Read/Write on the Component value","text":"<p>...<code>Cmd</code> means to command to change that container value like <code>LinearVelocityCmd</code>, <code>WorldPoseCmd</code>,    <code>VisualCmd</code></p>"},{"location":"common-code-system-plugin/#read","title":"Read","text":"a. Component <pre><code>//find Name component value of the entity(any entity_type eg model,link,world etc)\nauto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\nthis-&gt;modelName = Name-&gt;Data();\n</code></pre>"},{"location":"common-code-system-plugin/#write","title":"Write","text":"a. SetComponentData <pre><code>const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n//set the LinearVelocityCmd component value to be vel\n_ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n</code></pre> b. mutable component <pre><code>//set the LinearVelocityCmd component value to be vel\nauto velComp = _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\nvelComp-&gt;Data() = vel;\n</code></pre>"},{"location":"common-in-all-system.plugin/","title":"Common In All System Plugin","text":""},{"location":"common-in-all-system.plugin/#common-in-all-system-plugin","title":"Common In All System Plugin","text":"<p>1) Go to a standalone plugin folder: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins/&lt;plugin_name&gt;\n</code></pre></p> <p>2) Build: <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\ncd ..\n</code></pre></p> <p>3) Export plugin path (so Gazebo Sim can find it): <pre><code>export GZ_SIM_SYSTEM_PLUGIN_PATH=$(pwd)/build\n</code></pre></p> <p>4) Launch Gazebo Sim with an SDF: <pre><code>gazebo sim -v 4 &lt;sdf_file_path&gt;.sdf\n</code></pre></p> <p>Notes: - \"-v 4\" prints debug logs (useful while developing) - If Gazebo can\u2019t find the plugin, re-check GZ_SIM_SYSTEM_PLUGIN_PATH and that build succeeded.</p> <p></p>"},{"location":"common-in-all-system.plugin/#code-related","title":"Code related","text":""},{"location":"common-in-all-system.plugin/#_entity-of-configure","title":"<code>_entity</code> of Configure()","text":"<p><code>_entity</code> is the entity it attached to <code>world,model,light</code> etc </p> <pre><code>void PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n</code></pre> <p></p> <p><pre><code>&lt;world&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;&gt;\n\n&lt;/world&gt;\n</code></pre> so here <code>_entity</code> is world entity</p> <p></p> <p>here it <code>_entity</code> is model entity</p>"},{"location":"common-in-all-system.plugin/#plugin-in-xml","title":"Plugin in XML","text":"<p>need register the plugin with all the class it inhertited  <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre></p> <p>alias <pre><code>GZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre></p> <p>Important: only name=<code>gz::sim::systems::PrintEntitySystemPlugin</code> allowed for plugin you can't put any other name because it how we define on the alis <code>GZ_ADD_PLUGIN_ALIAS(...)</code></p> <p>so </p> <pre><code>&lt;!-- custom plugin attach to world--&gt;\n&lt;plugin\n    filename=\"PrintEntitySystemPlugin\"\n    name=\"gz::sim::systems::PrintEntitySystemPlugin\"&gt;\n&lt;/plugin&gt;\n</code></pre> <p><code>filename= PrintEntitySystemPlugin</code> </p> <p>or </p> <p><code>filename= libPrintEntitySystemPlugin.so</code> </p> <p>so no other name is allowed</p> <p>comes from CMakeList.txt</p> <pre><code>add_library(PrintEntitySystemPlugin SHARED PrintEntitySystemPlugin.cc)\nset_property(TARGET PrintEntitySystemPlugin PROPERTY CXX_STANDARD 17)\ntarget_link_libraries(PrintEntitySystemPlugin\n  PUBLIC gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}\n  PUBLIC gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER})\n</code></pre>"},{"location":"gz-structure-plugin-perspective/","title":"Gazebo Sim Structure Plugin Perspective","text":"<p>code/git repo for reference: - gz-system - gz-physics - gz-gui - gz-transport - gz-rendering</p> <p>will mainly focus on system plugin because they are main &amp; other have there own code base to do things like</p> <ul> <li><code>gz-physics</code> have code to calculation physics base on different physics engine(eg: dart) but at the end read/write on the components</li> <li><code>gz-gui</code> &amp; <code>gz-rendering</code> render scene or have gui made using Qt but end it also read/write on the system components</li> </ul> <p>same thing visible in gazebo sim architecture</p> <p></p>"},{"location":"inital_setup/","title":"Inital Setup for Tutorial","text":""},{"location":"inital_setup/#prerequisites","title":"Prerequisites","text":"<p>Common: - Git - A Linux environment (Ubuntu recommended)</p> <p>There are 2 way to do it:</p>"},{"location":"inital_setup/#1-without-using-docker","title":"1. Without Using docker","text":"<p>gazebo-sim-plugins-tutorial github</p> <pre><code>gazebo-sim-plugins-tutorial/\n\u251c\u2500\u2500 standalone_gz_sim_plugins/\n\u2502   \u251c\u2500\u2500 plugin_name_1/              # Standalone Gazebo Sim system plugin\n\u2502   \u251c\u2500\u2500 plugin_name_2/              # Standalone Gazebo Sim system plugin\n\u2502   \u2514\u2500\u2500 ...                         # More standalone plugins\n\u2502\n\u251c\u2500\u2500 ros2_ws/\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 yt_tutorial_gazebo_ros/      # ROS 2 Gazebo launch &amp; integration\n\u2502   \u2502   \u2514\u2500\u2500 tutorial_gazebo_plugins/     # ROS 2 Gazebo plugins\n\u2502   \u2514\u2500\u2500 ...                               # ROS 2 build, install, log folders\n\u2502\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"inital_setup/#needed","title":"Needed","text":"<ul> <li>ROS 2 installed on host</li> <li>Gazebo Sim installed on host</li> <li>Build tools (CMake / make)</li> <li>colcon (for ROS 2 workspace)</li> </ul> <p>NOTE: - Make sure you already have ROS 2 + Gazebo Sim installed on your system.  - The main difference vs Docker is simply where your X path points.</p> <p>Clone: <pre><code>git clone https://github.com/Hrithik-verma/gazebo-sim-plugins-tutorial.git\ncd gazebo-sim-plugins-tutorial\n</code></pre></p>"},{"location":"inital_setup/#build-run","title":"Build &amp; Run","text":""},{"location":"inital_setup/#a-standalone-gazebo-sim-plugins","title":"A) Standalone Gazebo Sim Plugins","text":"<p>1) Go to a standalone plugin folder: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins/&lt;plugin_name&gt;\n</code></pre></p> <p>2) Build: <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\ncd ..\n</code></pre></p> <p>3) Export plugin path (so Gazebo Sim can find it): <pre><code>export GZ_SIM_SYSTEM_PLUGIN_PATH=$(pwd)/build\n</code></pre></p> <p>4) Launch Gazebo Sim with an SDF: <pre><code>gazebo sim -v 4 &lt;sdf_file_path&gt;.sdf\n</code></pre></p> <p>Notes: - \"-v 4\" prints debug logs (useful while developing) - If Gazebo can\u2019t find the plugin, re-check GZ_SIM_SYSTEM_PLUGIN_PATH and that build succeeded.</p> <p></p>"},{"location":"inital_setup/#b-ros-2-workspace-ros2_ws","title":"B) ROS 2 Workspace (ros2_ws)","text":"<p>1) Go to the ROS 2 workspace: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/ros2_ws\n</code></pre></p> <p>2) Build ROS 2 packages: <pre><code>colcon build --symlink-install\n</code></pre></p> <p>3) Source the workspace: <pre><code>source install/setup.bash\n</code></pre></p> <p>4) Launch: <pre><code>ros2 launch yt_tutorial_gazebo_ros &lt;launch_file&gt;.launch.py\n</code></pre></p> <p> </p>"},{"location":"inital_setup/#2-using-docker","title":"2. Using Docker","text":"<p>ros2-jazzy-gazebo-harmonic-docker github</p> <pre><code>ros2-jazzy-gazebo-harmonic-docker/\n\u251c\u2500\u2500gazebo-sim-plugins-tutorial/   # other repo containing gazebo sim &amp; ros2 launch\n|    \u251c\u2500\u2500\u2500 standalone_gz_sim_plugins/\n\u2502    |     \u251c\u2500\u2500 plugin_name_1/              # Standalone Gazebo Sim system plugin\n\u2502    |     \u251c\u2500\u2500 plugin_name_2/              # Standalone Gazebo Sim system plugin\n\u2502    |     \u2514\u2500\u2500 ...                         # More standalone plugins\n\u2502    |\n|    \u251c\u2500\u2500 ros2_ws/\n\u2502           \u251c\u2500\u2500 src/\n\u2502           \u2502   \u251c\u2500\u2500 yt_tutorial_gazebo_ros/      # ROS 2 Gazebo launch &amp; integration\n\u2502           \u2502   \u2514\u2500\u2500 tutorial_gazebo_plugins/     # ROS 2 Gazebo plugins\n\u2502           \u2514\u2500\u2500 ...                               # ROS 2 build, install, log folders\n\u2502\n\u251c\u2500\u2500 README.md                    \n\u2502\n\u251c\u2500\u2500 Dockerfile   # docker file to make the docker image\n\u251c\u2500\u2500 docker-compose.yaml # docker container setup details \n\u2502\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"inital_setup/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/Hrithik-verma/ros2-jazzy-gazebo-harmonic-docker.git\ngit submodule update --init --recursive\n</code></pre>"},{"location":"inital_setup/#docker-setup","title":"Docker Setup","text":"<p>Build the docker container <pre><code>cd ros2-jazzy-gazebo-harmonic-docker\ndocker compose up -d\n</code></pre></p> <p>output: </p> <pre><code>[+] up 2/2ding layer 5f70bf18a086 32B / 32B     0.1s\n \u2714 Image jazzy-gz-harmonic-full    Built        323.2s \n \u2714 Container gz-tutorial-container Created     \n\n ```                                                 \n\ncheck image\n```bash\ndocker images\n</code></pre> <p>output: it shows image we build using <code>yt_tuturial_ws/Dockerfile</code> <pre><code>jazzy-gz-harmonic-full:latest             67661f9f23be       3.81GB             0B    U   \n</code></pre></p> <p>check image <pre><code>docker ps\n</code></pre></p> <p>output: output current running container <pre><code>docker ps\nCONTAINER ID   IMAGE                           COMMAND                  CREATED          STATUS          PORTS     NAMES\n61314940b998   jazzy-gz-harmonic-full          \"/ros_entrypoint.sh \u2026\"   10 minutes ago   Up 10 minutes             gz-tutorial-container\n</code></pre></p>"},{"location":"inital_setup/#run-container","title":"Run Container","text":"<p><code>Important:</code> container need to have display access for gazebo gui, rviz gui <pre><code>xhost +\n</code></pre></p> <p>go inside the container <pre><code>docker exec -it gz-tutorial-container bash\n</code></pre></p>"},{"location":"inital_setup/#check-container","title":"Check Container","text":"<p>To check if container is running or not. Container name not in the list that means it not running <pre><code>docker ps\n</code></pre></p> <p>start <pre><code>docker start gz-tutorial-container\n</code></pre> stop <pre><code>docker stop gz-tutorial-container\n</code></pre></p>"},{"location":"inital_setup/#docker-volume-shared","title":"Docker Volume Shared","text":"<p>In <code>ros2-jazzy-gazebo-harmonic-docker/docker-compose.yaml</code> </p> <pre><code> volumes:\n      - /tmp/.X11-unix:/tmp/.X11-unix:rw\n      - ./gazebo-sim-plugins-tutorial/ros2_ws:/root/ros2_ws\n      - ./gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins:/root/standalone_gz_sim_plugins\n</code></pre> <p><code>X11:</code> for display access  <code>ros2_ws</code>: entire ros2_ws is mounted inside root/ros2_ws. So any changes we make in ros2_ws will be reflected inside the container. <code>standalone_gz_sim_plugins</code> similary standalone_gz_sim_plugins is mounted inside root/standalone_gz_sim_plugins</p>"},{"location":"inital_setup/#troubleshooting","title":"Troubleshooting","text":"<p>GUI / Gazebo window not opening (Docker): - Ensure you ran: xhost + - Ensure DISPLAY is correctly passed into container (depends on your docker setup) - Display id is same in host &amp; container host &amp; docker container should have same <code>id</code> <pre><code>echo $DISPLAY\n</code></pre> output eg: <pre><code>$ echo $DISPLAY\n:0\n</code></pre></p> <p>if not export same display id in host &amp; docker container <pre><code>export DISPLAY=:0\n</code></pre></p>"},{"location":"print-entity-system-plugin/","title":"Print Entity System Plugin","text":"<p>PrintEntitySystemPlugin.hh</p> .hh file <pre><code>#ifndef WORLD_PLUGIN_HH\n#define WORLD_PLUGIN_HH\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;   //to inherit system\n#include \"gz/sim/components/Name.hh\" // for name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n/// \\brief plugin to move a model\n/// plugin interface.\nclass PrintEntitySystemPlugin :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    public gz::sim::ISystemPreUpdate\n{\npublic:\n    PrintEntitySystemPlugin();\n\n    ~PrintEntitySystemPlugin() override;\n\n    void Configure(const Entity &amp;_entity,\n                const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                EntityComponentManager &amp;_ecm,\n                EventManager &amp;_eventMgr) override;\n\n    void PreUpdate(const UpdateInfo &amp;_info,\n                EntityComponentManager &amp;_ecm) override;\n\nprivate:\n    std::string modelName;\n    Entity targetEntity;\n};\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> <p>PrintEntitySystemPlugin.cc</p> .cc file <pre><code>#include \"PrintEntitySystemPlugin.hh\"\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nPrintEntitySystemPlugin::PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin Started!!\"&lt;&lt;std::endl;\n}\nPrintEntitySystemPlugin::~PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin stopped!!\"&lt;&lt;std::endl;\n}\nvoid PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  this-&gt;targetEntity = _entity;\n  auto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\n  this-&gt;modelName = Name-&gt;Data();\n\n  gzmsg &lt;&lt; \"Target Entity value: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  gzmsg &lt;&lt; \"Target Entity Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n\n}\n\nvoid PrintEntitySystemPlugin::PreUpdate(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre> <p>lets understand code line by line</p>"},{"location":"print-entity-system-plugin/#hh-file-explanation","title":".hh file Explanation","text":"<p>include header files </p> <pre><code>#ifndef WORLD_PLUGIN_HH\n#define WORLD_PLUGIN_HH\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;   //to inherit system\n#include \"gz/sim/components/Name.hh\" // for name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n</code></pre> <p> all plugin are in gz::sim:::systems namespace <pre><code>namespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n/// \\brief plugin to move a model\n/// plugin interface.\nclass PrintEntitySystemPlugin :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    public gz::sim::ISystemPreUpdate\n{\npublic:\n    PrintEntitySystemPlugin();\n\n    ~PrintEntitySystemPlugin() override;\n\n    void Configure(const Entity &amp;_entity,\n                const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                EntityComponentManager &amp;_ecm,\n                EventManager &amp;_eventMgr) override;\n\n    void PreUpdate(const UpdateInfo &amp;_info,\n                EntityComponentManager &amp;_ecm) override;\n\nprivate:\n    std::string modelName;\n    Entity targetEntity;\n};\n}\n}\n}\n</code></pre></p> <p>PrintEntitySystemPlugin &lt;- inherits   - <code>gz::sim::System</code> :  needed for all system plugins   - <code>`gz::sim::ISystemConfigure</code>: needed for accesing sdf,entity   - <code>gz::sim::ISystemPreUpdate</code>: we are just reading data so even PostUpdate can be used but it not doing anything here. </p> <p>as we know from previous understanding as we inherit <code>ISystemConfigure</code> we need to write defination of <code>Configure()</code> function   &amp; same way <code>ISystemPreUpdate</code> we nee to write defination of <code>PreUpdate(..)</code> function</p> <p> </p>"},{"location":"print-entity-system-plugin/#cc-file-explanation","title":".cc file Explanation","text":"<p>same gz::sim:::systems namespace are added </p> <pre><code>#include \"PrintEntitySystemPlugin.hh\"\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n</code></pre> <p>prints added on constructor &amp; destructor </p> <p><pre><code>PrintEntitySystemPlugin::PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin Started!!\"&lt;&lt;std::endl;\n}\nPrintEntitySystemPlugin::~PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin stopped!!\"&lt;&lt;std::endl;\n}\n</code></pre> </p> <p>main code is</p> <p><code>_entity</code> is the entity it attached to <code>world,model,light</code> etc </p> <pre><code>void PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n</code></pre> <p></p> <p><pre><code>&lt;world&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;&gt;\n\n&lt;/world&gt;\n</code></pre> so here <code>_entity</code> is world entity</p> <p> </p> <pre><code>&lt;world&gt;\n\n  &lt;model&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;\n  &lt;/model&gt;\n\n&lt;/world&gt;\n</code></pre> <p>here it <code>_entity</code> is model entity</p> <p> means find the value of the Name Component attached to targetEntity </p> <pre><code>auto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\nthis-&gt;modelName = Name-&gt;Data();\n</code></pre> <p></p> <p></p> <p><code>Name-&gt;Data()</code>  why?  <code>-&gt;Data()</code> because its <code>std::optional&lt;entity&gt;</code></p> <p>need register the plugin with all the class it inhertited  <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre></p> <p>alias <pre><code>GZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre></p> <p>Important: only name=<code>gz::sim::systems::PrintEntitySystemPlugin</code> allowed for plugin you can't put any other name because it how we define on the alis <code>GZ_ADD_PLUGIN_ALIAS(...)</code></p> <p>so </p> <pre><code>&lt;!-- custom plugin attach to world--&gt;\n&lt;plugin\n    filename=\"PrintEntitySystemPlugin\"\n    name=\"gz::sim::systems::PrintEntitySystemPlugin\"&gt;\n&lt;/plugin&gt;\n</code></pre> <p><code>filename= PrintEntitySystemPlugin</code> </p> <p>or </p> <p><code>filename= libPrintEntitySystemPlugin.so</code> </p> <p>so no other name is allowed</p> <p>comes from CMakeList.txt</p> <pre><code>add_library(PrintEntitySystemPlugin SHARED PrintEntitySystemPlugin.cc)\nset_property(TARGET PrintEntitySystemPlugin PROPERTY CXX_STANDARD 17)\ntarget_link_libraries(PrintEntitySystemPlugin\n  PUBLIC gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}\n  PUBLIC gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER})\n</code></pre>"},{"location":"some_cplus_concept/","title":"Some C++ Concepts","text":""},{"location":"some_cplus_concept/#1namespace-in-c","title":"1.Namespace in C++","text":"<pre><code>#include &lt;iostream&gt;\n\nnamespace name_1{\n    namespace name_2{\n        int x;\n        void my_fn(){\n            std::cout&lt;&lt;\"hi\"&lt;&lt;std::endl;\n        }\n    }\n}\n\n\nint main() {\n\n    //access\n    name_1::name_2::x = 1;\n    name_1::name_2::my_fn();\n\n    return 0;\n\n}\n</code></pre> <p>similar you will a lot find in gazebo sim codes</p> <pre><code>namespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n\n\n.....\n\n}\n}\n}\n\n//access outside\ngz::sim::systems xyz; //means its inside gz , sim , systems namespace\n</code></pre> <p>so line like these <code>gz::transport::Node node;</code> means node in gz , transport namespace</p> <p>also means in the doc its under  <code>gz -&gt; transport</code> in the gazebo sim transport api doc </p> <p> </p>"},{"location":"some_cplus_concept/#2stdoptional","title":"2.std::optional","text":"<p>The term std::option refers to the std::optional class template in C++, which is used to represent a value that <code>may or may not be present.</code></p> <pre><code>std::optional&lt;std::string&gt; maybe_name = \"Alice\";\n\nif (maybe_name.has_value()) {  //has_value()\n    std::cout &lt;&lt; \"Name is: \" &lt;&lt; maybe_name.value() &lt;&lt; std::endl;  //value()\n}\n</code></pre> <p>so similarly in gazebo sim api also api example</p> <p></p> <pre><code>    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n</code></pre> <p> </p>"},{"location":"some_cplus_concept/#3this-pointer","title":"3.this pointer","text":"<pre><code>#include &lt;iostream&gt;\n\nclass person{\n  private:\n    int id;\n\n  public:\n   person(int id){\n     this-&gt;id = id;  // access data member\n                     // to avoid confusion id = id  \n   }\n\n   int show_id(){\n      return this-&gt;id; \n   }\n\n   void print_data(){\n       std::cout&lt;&lt; this-&gt;show_id() &lt;&lt; std::endl;  // accessing member funtion\n   }\n};\n\n\nint main() {\n    person a = person(5);\n    a.print_data();\n    return 0;\n}\n</code></pre> <p>similary, on plugin code many time we use this pointer </p>"},{"location":"system-plugin-interfaces/","title":"System Plugin Intefaces","text":"<p>official gazebo sim doc link</p> <p>comman line in any system plugin</p> <pre><code>class MoveModel :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    public gz::sim::ISystemPreUpdate,\n    //public gz::sim::ISystemUpdate,\n    //public gz::sim::ISystemPostUpdate\n</code></pre> <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModel,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre> <p><code>Note:</code> in inheriting which class what function needs to be defined</p> <ul> <li><code>gz::sim::ISystemConfigure</code>  -&gt; <code>Configure()</code></li> <li><code>gz::sim::ISystemPreUpdate</code>  -&gt; <code>PreUpdate()</code></li> <li><code>public gz::sim::ISystemUpdate</code>  -&gt; <code>Update()</code></li> <li><code>public gz::sim::ISystemPostUpdate</code>  -&gt; <code>PostUpdate()</code></li> </ul> <p> </p> <pre><code>void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\nvoid PreUpdate(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\nvoid Update(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nvoid PostUpdate(const UpdateInfo &amp;_info, const EntityComponentManager &amp;_ecm) override;  \n</code></pre> <p></p> <p>class api: ISystemConfigure,ISystemPreUpdate,ISystemUpdate, ISystemPostUpdate</p> <p>all of the above are pure virtual funtion because of which all need to defined in the derive class</p>"},{"location":"system-plugin-interfaces/#decide-on-interfaces-to-implement","title":"Decide on interfaces to implement","text":"<p>The first step of implementing a system plugin is to determine the subset of available interfaces to implement. Aside from the base System object, there are currently four additional available interfaces:</p> <p></p> <ol> <li>ISystemConfigure<ul> <li><code>read-write access</code></li> <li><code>Executed once</code></li> <li><code>SDF file</code> parameters define </li> </ul> </li> <li>ISystemPreUpdate<ul> <li><code>read-write access</code></li> <li><code>modify state before physics runs</code> </li> </ul> </li> <li>ISystemUpdate<ul> <li><code>read-write access</code> </li> <li>Used for <code>physics simulation step</code> (i.e., simulates what happens at time gz::sim::UpdateInfo::simTime). </li> </ul> </li> <li>ISystemPostUpdate<ul> <li><code>read-only access</code> </li> <li>Used to <code>read out results at the end of a simulation</code> step to be used for <code>sensor or controller updates</code>. </li> </ul> </li> <li>ISystemReset<ul> <li><code>read-write  access</code></li> <li><code>Executed once the moment the plugin is reseted.</code></li> </ul> </li> </ol>"},{"location":"what-is-ecs/","title":"Enitity Component System","text":""},{"location":"what-is-ecs/#what-is-ecs","title":"What Is ECS?","text":""},{"location":"what-is-ecs/#how-ecs-is-fast","title":"How ECS Is Fast?","text":"<p>let understand what is the actual problem &amp; how ecs solve it</p> <p><code>Modern CPUs are insanely fast at math but painfully slow at memory access</code></p> Operation Approx latency CPU register ~1 cycle L1 cache ~4 cycles L2 cache ~12 cycles L3 cache ~40 cycles RAM 200\u2013400 cycles \u274c <p>because RAM is slow cpu used cache for storing small data to process. </p> <p>But the problem with OOPS in traditional Object-Oriented Programming (OOP), you organize code by Objects.</p> <p>eg:</p> <pre><code>class model {\n    std::string modelName;     // owns heap memory (dynamic memory)\n    std::vector&lt;double&gt; pose;  // owns heap memory (dynamic memory)\n    float size[3];             // inline\n    float scale[3];            // inline\n};\n\n/* \n   modelObj is contiguous in memory.\n   However, std::string and std::vector store their data on the heap,\n   causing pointer indirection and non-contiguous access patterns,\n   which reduces cache efficiency in tight loops.\n*/\nmodel modelObj[2]; \n</code></pre> <p></p> <p>but modelName &amp; pose are discontinuous memory because of these it cause trouble to caching <code>The core problem is CPU cache inefficiency caused by memory layout</code></p> <p> </p>"},{"location":"what-is-ecs/#ecs-continuous-memory","title":"ECS Continuous Memory","text":"<p>ECS we just control components &amp; read/write on them one by one</p> <p></p> <p>First loop on modelName components, than loop on all Pose components Because of component now continuous memory is allocated</p> <p></p> <p></p>"}]}