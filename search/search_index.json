{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<pre><code>\ud83d\ude80 Lets Make Gazebo Sim Plugin Easy\n</code></pre> <p>   Motivation  As a beginer I personally find gazebo plugin to be very hard. In 2022,I made a bunch of tutorial for gazebo classic similary will do for gazebo sim. I always thought:</p> <ul> <li>what has changed from gazebo classic to sim?</li> <li>how gazebo plugin internally works?</li> <li>what is ECS? what are entity/components?</li> <li>where/how to read gazebo sim doc &amp; find useful info</li> <li>how to know which function to use?</li> </ul> <p>Finally, I'm here to answer all what where &amp; why. I feel so happy that I can share it with the world. Though this tutorials we decode all the secrets \ud83e\udd2b. We will learn every line of code in detail\ud83d\ude0d. </p>  \"Difficult part of gazebo plugin is not logic building rather how, when &amp; what function, msg, class &amp; Components(ECS) to use to code it. \"  <p>   Prerequisites  These are certain thing you need to know even before watching these tutorial series like <code>ros2</code>, basic of <code>gazebo sim</code>, <code>c++17</code> etc. Some good reference are:</p> <ol> <li> <p>OOPS in C++ At least some know of class, inheritance,  constructor,  virtual function</p> </li> <li> <p>Smart Pointers As we advance you will see will see that gazebo uses smart pointer a lot to point to classes &amp; function</p> </li> <li> <p>Entity Component System (ECS) ECS is the building block of gazebo sim &amp; ecs has be used in game engine for a long time now. Its better if you have some basic understanding of it.</p> </li> </ol> <p>A recommendation to download Visual Studio Code </p>"},{"location":"animal-actor-follow-waypoints-plugin/","title":"Animal Actor Follow WayPoints Plugin","text":"<p>In these tutoiral we are going to used a animated dog as a gazebo actor &amp; make it follow waypoints &amp; animate walking dog.</p> <p></p> <p>Download Blender Models </p> <p>Good Youtube Videos on Modelling &amp; Animal Animation: link1, link2</p>"},{"location":"animal-actor-follow-waypoints-plugin/#code-explain","title":"Code Explain","text":"<p>reakted api: gazebo components, Actor Wrapper Class, Actor.cc code in github</p> <p></p>"},{"location":"animal-actor-follow-waypoints-plugin/#1-how-the-actors-world-pose-is-computed","title":"1) How the actor\u2019s world pose is computed","text":"<pre><code>  auto originOpt = actor.Pose(_ecm);\n  if (!originOpt)\n  {\n    if (doPrint)\n      gzdbg &lt;&lt; \"[ActorWaypointSystem] Waiting for actor origin Pose component...\\n\";\n    return;\n  }\n  const math::Pose3d origin = *originOpt;\n\n  // TrajectoryPose\n  math::Pose3d traj = math::Pose3d::Zero;\n  if (auto trajComp = _ecm.Component&lt;components::TrajectoryPose&gt;(this-&gt;actorEntity))\n    traj = trajComp-&gt;Data();\n\n  // Derive current actor world pose from origin and trajectory\n  math::Pose3d world = origin * traj;\n</code></pre> <p>Instead of:</p> <p>world = origin \u2218 traj</p> <p>Read it as:</p> <p>\u201cStart at the origin pose, then apply the trajectory pose on top of it.\u201d</p> <p>In words:</p> <ul> <li>The actor has an origin pose that already lives in the world.</li> <li>The actor also has a trajectory pose that describes motion relative to that origin.</li> <li>To know where the actor actually is in the world:</li> <li>Take the origin pose</li> <li>Apply the trajectory pose\u2019s translation and rotation relative to that origin</li> </ul> <p>Result: - You get the final world position and orientation of the actor.</p> <p>Equivalent procedural explanation:</p> <ul> <li>Rotate the trajectory position by the origin rotation</li> <li>Add that rotated position to the origin position</li> <li>Multiply the origin rotation by the trajectory rotation</li> </ul>"},{"location":"animal-actor-follow-waypoints-plugin/#2-direction-toward-a-waypoint","title":"2) Direction toward a waypoint","text":"<pre><code>//current waypoint target\nconst math::Pose3d targetWorld = this-&gt;waypoints[this-&gt;currentWaypoint];\n\n// Direction in world frame\nmath::Vector3d dir = targetWorld.Pos() - world.Pos();\ndir.Z(0);                       // ignore Z for motion \nconst double dist = dir.Length();\n</code></pre> <p>Instead of vector subtraction notation, read it as:</p> <p>\u201cDirection = target position minus current position.\u201d</p> <p>In words:</p> <ul> <li>Look at where the actor is right now</li> <li>Look at where the waypoint is</li> <li>Draw an arrow from the actor to the waypoint</li> <li>That arrow is the direction vector</li> </ul> <p>Then:</p> <ul> <li>Set the vertical (Z) part of that arrow to zero   \u2192 movement is only on the ground plane</li> </ul>"},{"location":"animal-actor-follow-waypoints-plugin/#4-distance-to-waypoint","title":"4) Distance To WayPoint","text":"<pre><code>// Advance waypoint\nif (dist &lt; 0.05)\n{\nthis-&gt;currentWaypoint = (this-&gt;currentWaypoint + 1) % this-&gt;waypoints.size();\nif (doPrint)\n    gzdbg &lt;&lt; \"[ActorWaypointSystem] Reached waypoint, advancing to wp=\"\n        &lt;&lt; this-&gt;currentWaypoint &lt;&lt; \"\\n\";\nreturn;\n}\n\nif (dist &gt; 1e-9)\ndir.Normalize();\n</code></pre> <p>Instead of:</p> <p>dist = ||dir||</p> <p>Read it as:</p> <p>\u201cDistance is the length of the direction arrow.\u201d</p> <p>In words:</p> <ul> <li>Measure how long the arrow from actor to waypoint is</li> <li>That number tells you how far away the waypoint is</li> </ul> <p>If the distance is very small (less than 5 cm):</p> <ul> <li>Consider the waypoint reached</li> <li>Switch to the next waypoint</li> </ul> <p>Instead of:</p> <p>dir\u0302 = dir / ||dir||</p> <p>Read it as:</p> <p>\u201cScale the direction arrow so its length becomes exactly 1.\u201d</p> <p>In words:</p> <ul> <li>Keep the direction the same</li> <li>Change the arrow length to one unit</li> <li>This makes it usable for movement at a constant speed</li> </ul>"},{"location":"animal-actor-follow-waypoints-plugin/#6-how-far-the-actor-moves-this-update","title":"6) How far the actor moves this update","text":"<pre><code>// Step in world\n  world.Pos() += dir * step;\n\n  // Keep a constant height (or waypoint height) + offset\n  world.Pos().Z() = targetWorld.Pos().Z() + this-&gt;zOffset;\n\n  // Face direction\n  const double yaw = atan2(dir.Y(), dir.X());\n  world.Rot() = math::Quaterniond(0, 0, yaw + this-&gt;yawOffset);\n</code></pre> <p>Instead of:</p> <p>step = speed \u00d7 dt</p> <p>Read it as:</p> <p>\u201cDistance moved this frame equals speed multiplied by elapsed time.\u201d</p> <p>In words:</p> <ul> <li>Speed is meters per second</li> <li><code>dt</code> is seconds since the last update</li> <li>Multiply them to get meters moved this update</li> </ul> <p>Instead of writing a Z equation, read it as:</p> <p>\u201cIgnore vertical movement and snap the actor\u2019s height to the waypoint height plus an offset.\u201d</p> <p>In words:</p> <ul> <li>Z is not integrated over time</li> <li>Every update:</li> <li>Actor Z = waypoint Z + configured offset</li> </ul> <p>This guarantees stable vertical placement.</p> <p>Instead of:</p> <p>yaw = atan2(dy, dx)</p> <p>Read it as:</p> <p>\u201cCompute the angle that points in the same direction as the movement arrow.\u201d</p> <p>In words:</p> <ul> <li>Look at the direction arrow in the X\u2013Y plane</li> <li>Find the angle it makes relative to the X axis</li> <li>That angle becomes the actor\u2019s yaw</li> </ul> <p>Then:</p> <ul> <li>Add a yaw offset if configured</li> <li>Set roll and pitch to zero</li> </ul>"},{"location":"animal-actor-follow-waypoints-plugin/#7-converting-a-world-pose-back-into-trajectory-space","title":"7) Converting a world pose back into trajectory space","text":"<pre><code>  // Convert desired world pose -&gt; trajectory (relative to origin)\n  // world = origin * traj  =&gt;  traj = origin^-1 * world\n  const math::Pose3d trajCmd = origin.Inverse() * world;\n\n  // Set manual trajectory pose\n  actor.SetTrajectoryPose(_ecm, trajCmd);\n\n  // Force notify that this component changed (this is the key)\n  _ecm.SetChanged(this-&gt;actorEntity,\n                  gz::sim::components::TrajectoryPose::typeId,\n                  gz::sim::ComponentState::OneTimeChange);\n</code></pre> <p>Instead of:</p> <p>trajCmd = origin\u207b\u00b9 \u2218 world</p> <p>Read it as:</p> <p>\u201cRemove the origin pose from the world pose to get a trajectory-relative pose.\u201d</p> <p>In words:</p> <ul> <li>You already know where the actor should be in the world.</li> <li>But the system only accepts trajectory poses (relative to origin).</li> <li>So you:</li> <li>Undo the origin\u2019s rotation and translation</li> <li>Express the world pose relative to the origin frame</li> </ul> <p>This answers the question:</p> <p>\u201cWhat trajectory pose would produce this world pose if applied on top of the origin?\u201d</p>"},{"location":"animal-actor-follow-waypoints-plugin/#8-full-update-logic-in-plain-english","title":"8) Full update logic in plain English","text":"<p>Each simulation update does the following:</p> <ol> <li>Read the actor\u2019s origin pose</li> <li>Read the actor\u2019s trajectory pose</li> <li>Combine them to get the current world pose</li> <li>Compute a flat (X\u2013Y) direction toward the current waypoint</li> <li>Measure distance to the waypoint</li> <li>If close enough:</li> <li>Advance to the next waypoint</li> <li>Otherwise:</li> <li>Move forward by <code>speed \u00d7 dt</code></li> <li>Set height to waypoint Z + offset</li> <li>Rotate the actor to face the movement direction</li> <li>Convert the resulting world pose back into a trajectory pose</li> <li>Write that trajectory pose back to the ECS</li> </ol>"},{"location":"animal-actor-follow-waypoints-plugin/#plugin","title":"Plugin","text":".sdf file plugin path <pre><code>&lt;include&gt;\n  &lt;name&gt;dog_walk&lt;/name&gt;\n  &lt;pose&gt;0 0 0.01 0 0 0&lt;/pose&gt;\n  &lt;uri&gt;model://dog_walk&lt;/uri&gt;\n\n  &lt;plugin\n    filename=\"AnimalActorFollowWaypoints\"\n    name=\"gz::sim::AnimalActorFollowWaypoints\"&gt;\n\n    &lt;waypoint&gt;0 0 0 0 0 0&lt;/waypoint&gt;\n    &lt;waypoint&gt;0 8 0 0 0 0&lt;/waypoint&gt;\n    &lt;waypoint&gt;8 8 0 0 0 1.57&lt;/waypoint&gt;\n    &lt;waypoint&gt;0 8 0 0 0 3.14&lt;/waypoint&gt;\n\n    &lt;speed&gt;0.1&lt;/speed&gt;\n    &lt;yaw_offset&gt;0.0&lt;/yaw_offset&gt;   \n    &lt;z_offset&gt;0.01&lt;/z_offset&gt; \n\n  &lt;/plugin&gt;\n&lt;/include&gt;\n</code></pre> .hh file <pre><code>#pragma once\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/Entity.hh&gt;\n#include &lt;gz/sim/EntityComponentManager.hh&gt;\n\n#include &lt;gz/sim/components/Actor.hh&gt;\n#include &lt;gz/sim/components/Pose.hh&gt;\n#include &lt;gz/sim/components.hh&gt;\n#include &lt;gz/sim/Actor.hh&gt;\n\n#include &lt;gz/math/Pose3.hh&gt;\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;vector&gt;\n\nnamespace gz::sim\n{\n\nclass AnimalActorFollowWaypoints :\n  public System,\n  public ISystemConfigure,\n  public ISystemPreUpdate\n{\npublic:\n  void Configure(\n    const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;) override;\n\n  void PreUpdate(\n    const UpdateInfo &amp;_info,\n    EntityComponentManager &amp;_ecm) override;\n\nprivate:\n  Entity actorEntity{kNullEntity};\n\n  std::vector&lt;math::Pose3d&gt; waypoints;\n  size_t currentWaypoint{0};\n  std::chrono::steady_clock::time_point lastWallPrint{};\n  double yawOffset;\n  double zOffset{0.0};\n\n\n  double speed{1.0}; // meters / second\n};\n\n}\n</code></pre> .cc file <pre><code>#include \"tutorial_gazebo_plugins/AnimalActorFollowWaypoints.hh\"\n\n#include &lt;gz/common/Console.hh&gt;\n#include &lt;gz/math/Vector3.hh&gt;\n\nusing namespace gz;\nusing namespace sim;\n\n//////////////////////////////////////////////////\nvoid AnimalActorFollowWaypoints::Configure(\n  const Entity &amp;,\n  const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n  EntityComponentManager &amp;_ecm,\n  EventManager &amp;)\n{\n  // Find actor\n  _ecm.Each&lt;components::Actor&gt;(\n    [&amp;](const Entity &amp;_ent, const components::Actor *) -&gt; bool\n    {\n      this-&gt;actorEntity = _ent;\n      return false;\n    });\n\n  if (this-&gt;actorEntity == kNullEntity)\n  {\n    gzerr &lt;&lt; \"[AnimalActorFollowWaypoints] No Actor found\\n\";\n    return;\n  }\n\n   if (!_ecm.Component&lt;components::Actor&gt;(this-&gt;actorEntity))\n  {\n    gzerr &lt;&lt; \"[AnimalActorFollowWaypoints] Plugin attached to a non-actor entity\\n\";\n    return;\n  }\n\n  // Read waypoints\n  for (auto elem = _sdf-&gt;FindElement(\"waypoint\");\n       elem; elem = elem-&gt;GetNextElement(\"waypoint\"))\n  {\n    this-&gt;waypoints.push_back(elem-&gt;Get&lt;math::Pose3d&gt;());\n  }\n\n  if (_sdf-&gt;HasElement(\"speed\"))\n    this-&gt;speed = _sdf-&gt;Get&lt;double&gt;(\"speed\");\n\n  if (this-&gt;waypoints.empty())\n    gzerr &lt;&lt; \"[AnimalActorFollowWaypoints] No waypoints provided\\n\";\n\n  if (_sdf-&gt;HasElement(\"yaw_offset\"))\n    this-&gt;yawOffset = _sdf-&gt;Get&lt;double&gt;(\"yaw_offset\");\n\n  if (_sdf-&gt;HasElement(\"z_offset\"))\n    this-&gt;zOffset = _sdf-&gt;Get&lt;double&gt;(\"z_offset\");\n\n  gzdbg &lt;&lt; \"[AnimalActorFollowWaypoints] Configure: actorEntity=\" &lt;&lt; this-&gt;actorEntity\n      &lt;&lt; \" waypoints=\" &lt;&lt; this-&gt;waypoints.size()\n      &lt;&lt; \" speed=\" &lt;&lt; this-&gt;speed &lt;&lt; \"\\n\";\n}\n\nvoid AnimalActorFollowWaypoints::PreUpdate(\n  const UpdateInfo &amp;_info,\n  EntityComponentManager &amp;_ecm)\n{\n  if (_info.paused)\n    return;\n\n  if (this-&gt;waypoints.empty())\n    return;\n\n  // Throttle debug prints (~1 Hz)\n  const auto now = std::chrono::steady_clock::now();\n  const bool doPrint =\n    (this-&gt;lastWallPrint.time_since_epoch().count() == 0) ||\n    (now - this-&gt;lastWallPrint &gt; std::chrono::seconds(1));\n  if (doPrint)\n    this-&gt;lastWallPrint = now;\n\n\n  //\n  gz::sim::Actor actor(this-&gt;actorEntity);\n  if (!actor.Valid(_ecm))\n  {\n    if (doPrint)\n      gzerr &lt;&lt; \"[AnimalActorFollowWaypoints] PreUpdate: entity \" &lt;&lt; this-&gt;actorEntity\n            &lt;&lt; \" not a valid Actor\\n\";\n    return;\n  }\n\n  // Origin pose (trajectory reference)\n  auto originOpt = actor.Pose(_ecm);\n  if (!originOpt)\n  {\n    if (doPrint)\n      gzdbg &lt;&lt; \"[AnimalActorFollowWaypoints] Waiting for actor origin Pose component...\\n\";\n    return;\n  }\n  const math::Pose3d origin = *originOpt;\n\n  // TrajectoryPose\n  math::Pose3d traj = math::Pose3d::Zero;\n  if (auto trajComp = _ecm.Component&lt;components::TrajectoryPose&gt;(this-&gt;actorEntity))\n    traj = trajComp-&gt;Data();\n\n  // Derive current actor world pose from origin and trajectory\n  math::Pose3d world = origin * traj;\n\n  //current waypoint target\n  const math::Pose3d targetWorld = this-&gt;waypoints[this-&gt;currentWaypoint];\n\n  // Direction in world frame\n  math::Vector3d dir = targetWorld.Pos() - world.Pos();\n  dir.Z(0);                       // ignore Z for motion \n  const double dist = dir.Length();\n\n  if (doPrint)\n  {\n    gzdbg &lt;&lt; \"[AnimalActorFollowWaypoints] Tick entity=\" &lt;&lt; this-&gt;actorEntity\n          &lt;&lt; \" wp=\" &lt;&lt; this-&gt;currentWaypoint &lt;&lt; \"/\" &lt;&lt; this-&gt;waypoints.size()\n          &lt;&lt; \" dt=\" &lt;&lt; std::chrono::duration&lt;double&gt;(_info.dt).count()\n          &lt;&lt; \" origin.pos=\" &lt;&lt; origin.Pos()\n          &lt;&lt; \" world.pos=\" &lt;&lt; world.Pos()\n          &lt;&lt; \" traj.pos=\" &lt;&lt; traj.Pos()\n          &lt;&lt; \" target.pos=\" &lt;&lt; targetWorld.Pos()\n          &lt;&lt; \" dist=\" &lt;&lt; dist\n          &lt;&lt; \"\\n\";\n  }\n\n  // Advance waypoint\n  if (dist &lt; 0.05)\n  {\n    this-&gt;currentWaypoint = (this-&gt;currentWaypoint + 1) % this-&gt;waypoints.size();\n    if (doPrint)\n      gzdbg &lt;&lt; \"[AnimalActorFollowWaypoints] Reached waypoint, advancing to wp=\"\n            &lt;&lt; this-&gt;currentWaypoint &lt;&lt; \"\\n\";\n    return;\n  }\n\n  if (dist &gt; 1e-9)\n    dir.Normalize();\n\n  //this-&gt;speed * dt means  Distance covered in one physics frame\n  const double dt = std::chrono::duration&lt;double&gt;(_info.dt).count();\n  const double step = this-&gt;speed * dt;\n\n  // Step in world\n  world.Pos() += dir * step;\n\n  // Keep a constant height (or waypoint height) + offset\n  world.Pos().Z() = targetWorld.Pos().Z() + this-&gt;zOffset;\n\n  // Face direction\n  const double yaw = atan2(dir.Y(), dir.X());\n  world.Rot() = math::Quaterniond(0, 0, yaw + this-&gt;yawOffset);\n\n  // Convert desired world pose -&gt; trajectory (relative to origin)\n  // world = origin * traj  =&gt;  traj = origin^-1 * world\n  const math::Pose3d trajCmd = origin.Inverse() * world;\n\n  // Set manual trajectory pose\n  actor.SetTrajectoryPose(_ecm, trajCmd);\n\n  // Force notify that this component changed (this is the key)\n  _ecm.SetChanged(this-&gt;actorEntity,\n                  gz::sim::components::TrajectoryPose::typeId,\n                  gz::sim::ComponentState::OneTimeChange);\n\n\n  if (doPrint)\n  {\n    gzdbg &lt;&lt; \"[AnimalActorFollowWaypoints] SetTrajectoryPose traj(before)=\" &lt;&lt; traj.Pos()\n          &lt;&lt; \" trajCmd(after)=\" &lt;&lt; trajCmd.Pos()\n          &lt;&lt; \" world(after)=\" &lt;&lt; world.Pos()\n          &lt;&lt; \" yaw=\" &lt;&lt; yaw\n          &lt;&lt; \"\\n\";\n  }\n}\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::AnimalActorFollowWaypoints,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::AnimalActorFollowWaypoints,\n                    \"gz::sim::systems::AnimalActorFollowWaypoints\")\n</code></pre> <p><code>GZ_SIM_RESOURCE_PATH</code> added so that gazebo sim can find model path</p> launch file <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, ExecuteProcess\nfrom launch.substitutions import LaunchConfiguration, FindExecutable\nfrom launch_ros.actions import Node\nfrom launch import LaunchDescription\nfrom launch.actions import SetEnvironmentVariable, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.substitutions import PathJoinSubstitution\n\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n\n    plugin_pkg_path = FindPackageShare('tutorial_gazebo_plugins')\n\n    ros_pkg_path = FindPackageShare('yt_tutorial_gazebo_ros')\n\n    set_plugin_path = SetEnvironmentVariable(\n    'GZ_SIM_SYSTEM_PLUGIN_PATH',\n    PathJoinSubstitution([plugin_pkg_path, 'plugins'])\n    )\n\n    # to load models\n    set_model_path = SetEnvironmentVariable(\n    'GZ_SIM_RESOURCE_PATH',\n    PathJoinSubstitution([ros_pkg_path, 'models'])\n    )\n\n    world_path = os.path.join(\n        get_package_share_directory('yt_tutorial_gazebo_ros'),\n        'worlds',\n        'animal_actor_follow_waypoints.sdf',\n    )\n\n    ros_gz_sim_share = get_package_share_directory('ros_gz_sim')\n\n    gz_sim = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(ros_gz_sim_share, 'launch', 'gz_sim.launch.py')\n        ),\n        launch_arguments={\n            # see next section for -v\n            'gz_args': f'-r -v4 {world_path}',\n        }.items(),\n    )\n\n\n\n\n    return LaunchDescription([set_plugin_path,set_model_path, gz_sim])\n</code></pre>"},{"location":"common-code-system-plugin/","title":"Common Used System Plugin API","text":"<p>important part in api doc:     - gz::sim     - gz::sim::EntityComponentManager     - gz::sim::components</p>"},{"location":"common-code-system-plugin/#understand-component","title":"Understand Component","text":"<pre><code>using X = Component&lt;DataType, class Tag&gt;;\n\n//        or \n\nusing X = Component&lt;DataType, class Tag, Serializer&gt;;\n</code></pre> <p>to access component: <code>components::X</code> , <code>X</code> is the component Name  Datatype: data type of that component  Serializer: use for data transfer (not so important) </p> <p></p> <p></p> <p></p> <p>access:  - <code>components::Name</code> - <code>components::LinearVelocity</code> - <code>components::Model</code></p> <p> </p>"},{"location":"common-code-system-plugin/#system-plugin-steps","title":"System Plugin Steps","text":""},{"location":"common-code-system-plugin/#1-find-the-entity","title":"1. Find The Entity","text":"<p>We will take help of components to find entity integer value like:</p> <ul> <li>has <code>Name</code> component of value <code>xyz</code></li> <li>has both <code>Entity</code> and <code>Name</code> components</li> </ul> a. plugin is directly attached to entity       in world file .sdf     <pre><code> &lt;model&gt;\n    ...\n\n    &lt;plugin&gt;..... &lt;/plugin&gt;   \n &lt;/model&gt;\n</code></pre>      code      <pre><code> void MoveModel::Configure(const Entity &amp;_entity, const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                    EntityComponentManager &amp;_ecm,\n                    EventManager &amp;/*_eventMgr*/){\n        // _entity --&gt; is the entity of model\n        entity = _entity;\n}\n</code></pre> b. search the entity by its name <pre><code>   // find the entity (int value) which has Name Component with value as \"xyz\"\n   targetEntity = _ecm.EntityByComponents(components::Name(\"xyz\"));\n</code></pre> <pre><code>auto entityOpt = _ecm.EntityByName(\"abc\");\nentity = entityOpt.value()\n</code></pre> c. find multiple entity <pre><code>//check for such components which has Light, Name components\n// each\n_ecm.Each&lt;components::Light, components::Name&gt;(\n  [&amp;](const Entity &amp;_entity,\n      const components::Light *,\n      const components::Name *_name) -&gt; bool\n  {\n    this-&gt;lightEntites.push_back(_entity);\n    // gzmsg &lt;&lt; \"Found light: \" &lt;&lt; _name-&gt;Data()\n    //       &lt;&lt; \" (entity \" &lt;&lt; _entity &lt;&lt; \")\\n\";\n    return true;\n  });\n</code></pre> d. find EntityByComponents  uing ```EntityByComponents()```  find such a joint entity which has all of the followings components:         parent entity is ***model component*** to which plugin is attached,         has a ***name component*** of value ```joint_1```          ***joint compenent*** is attach on it  [reference code](https://github.com/gazebosim/gz-sim/blob/gz-sim8/src/Model.cc#L132C1-L133C1)  <pre><code>  this-&gt;jointEntity = _ecm.EntityByComponents(\n      components::ParentEntity(_entity),\n      components::Name(jointName),\n      components::Joint());\n</code></pre>  ### 2. Read/Write on the Component value ![command](assets/images/cmd_component.png)  ...``Cmd`` means to command to change that container value like ```LinearVelocityCmd```, ```WorldPoseCmd```,    ```VisualCmd```  ### Read  a. Component <pre><code>//find Name component value of the entity(any entity_type eg model,link,world etc)\nauto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\nthis-&gt;modelName = Name-&gt;Data();\n</code></pre>    #### Write   a. SetComponentData <pre><code>const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n//set the LinearVelocityCmd component value to be vel\n_ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n</code></pre> b. mutable component <pre><code>//set the LinearVelocityCmd component value to be vel\nauto velComp = _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\nvelComp-&gt;Data() = vel;\n</code></pre>"},{"location":"common-in-all-ros2-ws-plugins/","title":"Common Things In All ros2_ws Plugins","text":""},{"location":"common-in-all-ros2-ws-plugins/#structure","title":"Structure","text":"<pre><code>\u251c\u2500\u2500 ros2_ws/\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 yt_tutorial_gazebo_ros/      # ROS 2 Gazebo launch &amp; integration\n|   |   |      \u2514\u2500\u2500config\n|   |   |      \u2514\u2500\u2500launch\n|   |   |      \u2514\u2500\u2500worlds\n|   |   |      \u2514\u2500\u2500CmakeLists.txt\n|   |   |      \u2514\u2500\u2500package.xml\n\u2502   \u2502   \u2514\u2500\u2500 tutorial_gazebo_plugins/     # ROS 2 Gazebo plugins\n|   |          \u2514\u2500\u2500include                # Plugin .hh file\n|   |          \u2514\u2500\u2500src                    # Plugin .cc file\n\u2502   \u2514\u2500\u2500 ...                               # ROS 2 build, install, log folders\n\u2502\n</code></pre>"},{"location":"common-in-all-ros2-ws-plugins/#ros2-gazebo-sim-plugin","title":"ROS2 Gazebo Sim Plugin","text":"<p>There are 2 ways:</p> <ol> <li>Using ros-gz-bridge</li> <li>Using Direct rclcpp in gazebo sim plugin</li> </ol> <p></p>"},{"location":"common-in-all-ros2-ws-plugins/#naming-convention-in-the-tutorial","title":"Naming Convention In The Tutorial","text":"<p><code>&lt;Name&gt;</code> - pure gazebo sim plugin <code>&lt;Name&gt;TopicWay</code>  - using ros2 gz bridge to communicate <code>&lt;Name&gt;DirectRos</code> - using ros2 rclcpp directly in gazebo sim plugin</p> <p> </p>"},{"location":"common-in-all-ros2-ws-plugins/#launch-file","title":"launch file","text":"<ul> <li><code>GZ_SIM_SYSTEM_PLUGIN_PATH</code> variable is added in the launch file</li> <li>gz sim launch using <code>ros_gz_sim</code> pkg &amp; <code>'gz_sim.launch.py</code> launch file</li> </ul> <pre><code>    plugin_pkg_path = FindPackageShare('tutorial_gazebo_plugins')\n\n    set_plugin_path = SetEnvironmentVariable(\n    'GZ_SIM_SYSTEM_PLUGIN_PATH',\n    PathJoinSubstitution([plugin_pkg_path, 'plugins'])\n    )\n\n    world_path = os.path.join(\n        get_package_share_directory('yt_tutorial_gazebo_ros'),\n        'worlds',\n        'move_model_topic_way.sdf',\n    )\n\n    ros_gz_sim_share = get_package_share_directory('ros_gz_sim')\n\n    gz_sim = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(ros_gz_sim_share, 'launch', 'gz_sim.launch.py')\n        ),\n        launch_arguments={\n            # see next section for -v\n            'gz_args': f'-r -v4 {world_path}',\n        }.items(),\n    )\n</code></pre>"},{"location":"common-in-all-ros2-ws-plugins/#build-run-ros2-pkg","title":"Build &amp; Run ros2 pkg","text":"<pre><code>cd ros2_ws\ncolcon build --symlink-install\n</code></pre> <pre><code>source install/setup.bash\nros2 launch yt_tutorial_gazebo_ros &lt;name&gt;.launch.py\n</code></pre>"},{"location":"common-in-all-system.plugin/","title":"Common In All System Plugin","text":""},{"location":"common-in-all-system.plugin/#common-in-all-system-plugin","title":"Common In All System Plugin","text":"<p>1) Go to a standalone plugin folder: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins/&lt;plugin_name&gt;\n</code></pre></p> <p>2) Build: <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\ncd ..\n</code></pre></p> <p>3) Export plugin path (so Gazebo Sim can find it): <pre><code>export GZ_SIM_SYSTEM_PLUGIN_PATH=$(pwd)/build\n</code></pre></p> <p>4) Launch Gazebo Sim with an SDF: <pre><code>gazebo sim -v 4 &lt;sdf_file_path&gt;.sdf\n</code></pre></p> <p>Notes: - \"-v 4\" prints debug logs (useful while developing) - If Gazebo can\u2019t find the plugin, re-check GZ_SIM_SYSTEM_PLUGIN_PATH and that build succeeded.</p> <p></p>"},{"location":"common-in-all-system.plugin/#code-related","title":"Code related","text":""},{"location":"common-in-all-system.plugin/#_entity-of-configure","title":"<code>_entity</code> of Configure()","text":"<p><code>_entity</code> is the entity it attached to <code>world,model,light</code> etc </p> <pre><code>void PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n</code></pre> <p></p> <p><pre><code>&lt;world&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;&gt;\n\n&lt;/world&gt;\n</code></pre> so here <code>_entity</code> is world entity</p> <p></p> <p>here it <code>_entity</code> is model entity</p>"},{"location":"common-in-all-system.plugin/#plugin-in-xml","title":"Plugin in XML","text":"<p>need register the plugin with all the class it inhertited  <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre></p> <p>alias <pre><code>GZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre></p> <p>Important: only name=<code>gz::sim::systems::PrintEntitySystemPlugin</code> allowed for plugin you can't put any other name because it how we define on the alis <code>GZ_ADD_PLUGIN_ALIAS(...)</code></p> <p>so </p> <pre><code>&lt;!-- custom plugin attach to world--&gt;\n&lt;plugin\n    filename=\"PrintEntitySystemPlugin\"\n    name=\"gz::sim::systems::PrintEntitySystemPlugin\"&gt;\n&lt;/plugin&gt;\n</code></pre> <p><code>filename= PrintEntitySystemPlugin</code> </p> <p>or </p> <p><code>filename= libPrintEntitySystemPlugin.so</code> </p> <p>so no other name is allowed</p> <p>comes from CMakeList.txt</p> <pre><code>add_library(PrintEntitySystemPlugin SHARED PrintEntitySystemPlugin.cc)\nset_property(TARGET PrintEntitySystemPlugin PROPERTY CXX_STANDARD 17)\ntarget_link_libraries(PrintEntitySystemPlugin\n  PUBLIC gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}\n  PUBLIC gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER})\n</code></pre>"},{"location":"gz-structure-plugin-perspective/","title":"Gazebo Sim Structure Plugin Perspective","text":"<p>code/git repo for reference: - gz-system - gz-physics - gz-gui - gz-transport - gz-rendering</p> <p>will mainly focus on system plugin because they are main &amp; other have there own code base to do things like</p> <ul> <li><code>gz-physics</code> have code to calculation physics base on different physics engine(eg: dart) but at the end read/write on the components</li> <li><code>gz-gui</code> &amp; <code>gz-rendering</code> render scene or have gui made using Qt but end it also read/write on the system components</li> </ul> <p>same thing visible in gazebo sim architecture</p> <p></p>"},{"location":"inital_setup/","title":"Inital Setup for Tutorial","text":""},{"location":"inital_setup/#prerequisites","title":"Prerequisites","text":"<p>Common: - Git - A Linux environment (Ubuntu recommended)</p> <p>There are 2 way to do it:</p>"},{"location":"inital_setup/#1-without-using-docker","title":"1. Without Using docker","text":"<p>gazebo-sim-plugins-tutorial github</p> <pre><code>gazebo-sim-plugins-tutorial/\n\u251c\u2500\u2500 standalone_gz_sim_plugins/\n\u2502   \u251c\u2500\u2500 plugin_name_1/              # Standalone Gazebo Sim system plugin\n\u2502   \u251c\u2500\u2500 plugin_name_2/              # Standalone Gazebo Sim system plugin\n\u2502   \u2514\u2500\u2500 ...                         # More standalone plugins\n\u2502\n\u251c\u2500\u2500 ros2_ws/\n\u2502   \u251c\u2500\u2500 src/\n\u2502   \u2502   \u251c\u2500\u2500 yt_tutorial_gazebo_ros/      # ROS 2 Gazebo launch &amp; integration\n\u2502   \u2502   \u2514\u2500\u2500 tutorial_gazebo_plugins/     # ROS 2 Gazebo plugins\n\u2502   \u2514\u2500\u2500 ...                               # ROS 2 build, install, log folders\n\u2502\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"inital_setup/#needed","title":"Needed","text":"<ul> <li>ROS 2 installed on host</li> <li>Gazebo Sim installed on host</li> <li>Build tools (CMake / make)</li> <li>colcon (for ROS 2 workspace)</li> </ul> <p>NOTE: - Make sure you already have ROS 2 + Gazebo Sim installed on your system.  - The main difference vs Docker is simply where your X path points.</p> <p>Clone: <pre><code>git clone https://github.com/Hrithik-verma/gazebo-sim-plugins-tutorial.git\ncd gazebo-sim-plugins-tutorial\n</code></pre></p>"},{"location":"inital_setup/#build-run","title":"Build &amp; Run","text":""},{"location":"inital_setup/#a-standalone-gazebo-sim-plugins","title":"A) Standalone Gazebo Sim Plugins","text":"<p>1) Go to a standalone plugin folder: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins/&lt;plugin_name&gt;\n</code></pre></p> <p>2) Build: <pre><code>mkdir build &amp;&amp; cd build\ncmake ..\nmake\ncd ..\n</code></pre></p> <p>3) Export plugin path (so Gazebo Sim can find it): <pre><code>export GZ_SIM_SYSTEM_PLUGIN_PATH=$(pwd)/build\n</code></pre></p> <p>4) Launch Gazebo Sim with an SDF: <pre><code>gazebo sim -v 4 &lt;sdf_file_path&gt;.sdf\n</code></pre></p> <p>Notes: - \"-v 4\" prints debug logs (useful while developing) - If Gazebo can\u2019t find the plugin, re-check GZ_SIM_SYSTEM_PLUGIN_PATH and that build succeeded.</p> <p></p>"},{"location":"inital_setup/#b-ros-2-workspace-ros2_ws","title":"B) ROS 2 Workspace (ros2_ws)","text":"<p>1) Go to the ROS 2 workspace: <pre><code>cd &lt;path-to&gt;/gazebo-sim-plugins-tutorial/ros2_ws\n</code></pre></p> <p>2) Build ROS 2 packages: <pre><code>colcon build --symlink-install\n</code></pre></p> <p>3) Source the workspace: <pre><code>source install/setup.bash\n</code></pre></p> <p>4) Launch: <pre><code>ros2 launch yt_tutorial_gazebo_ros &lt;launch_file&gt;.launch.py\n</code></pre></p> <p> </p>"},{"location":"inital_setup/#2-using-docker","title":"2. Using Docker","text":"<p>ros2-jazzy-gazebo-harmonic-docker github</p> <pre><code>ros2-jazzy-gazebo-harmonic-docker/\n\u251c\u2500\u2500gazebo-sim-plugins-tutorial/   # other repo containing gazebo sim &amp; ros2 launch\n|    \u251c\u2500\u2500\u2500 standalone_gz_sim_plugins/\n\u2502    |     \u251c\u2500\u2500 plugin_name_1/              # Standalone Gazebo Sim system plugin\n\u2502    |     \u251c\u2500\u2500 plugin_name_2/              # Standalone Gazebo Sim system plugin\n\u2502    |     \u2514\u2500\u2500 ...                         # More standalone plugins\n\u2502    |\n|    \u251c\u2500\u2500 ros2_ws/\n\u2502           \u251c\u2500\u2500 src/\n\u2502           \u2502   \u251c\u2500\u2500 yt_tutorial_gazebo_ros/      # ROS 2 Gazebo launch &amp; integration\n\u2502           \u2502   \u2514\u2500\u2500 tutorial_gazebo_plugins/     # ROS 2 Gazebo plugins\n\u2502           \u2514\u2500\u2500 ...                               # ROS 2 build, install, log folders\n\u2502\n\u251c\u2500\u2500 README.md                    \n\u2502\n\u251c\u2500\u2500 Dockerfile   # docker file to make the docker image\n\u251c\u2500\u2500 docker-compose.yaml # docker container setup details \n\u2502\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"inital_setup/#clone","title":"Clone","text":"<pre><code>git clone https://github.com/Hrithik-verma/ros2-jazzy-gazebo-harmonic-docker.git\ngit submodule update --init --recursive\n</code></pre>"},{"location":"inital_setup/#docker-setup","title":"Docker Setup","text":"<p>Build the docker container <pre><code>cd ros2-jazzy-gazebo-harmonic-docker\ndocker compose up -d\n</code></pre></p> <p>output: </p> <pre><code>[+] up 2/2ding layer 5f70bf18a086 32B / 32B     0.1s\n \u2714 Image jazzy-gz-harmonic-full    Built        323.2s \n \u2714 Container gz-tutorial-container Created     \n\n ```                                                 \n\ncheck image\n```bash\ndocker images\n</code></pre> <p>output: it shows image we build using <code>yt_tuturial_ws/Dockerfile</code> <pre><code>jazzy-gz-harmonic-full:latest             67661f9f23be       3.81GB             0B    U   \n</code></pre></p> <p>check image <pre><code>docker ps\n</code></pre></p> <p>output: output current running container <pre><code>docker ps\nCONTAINER ID   IMAGE                           COMMAND                  CREATED          STATUS          PORTS     NAMES\n61314940b998   jazzy-gz-harmonic-full          \"/ros_entrypoint.sh \u2026\"   10 minutes ago   Up 10 minutes             gz-tutorial-container\n</code></pre></p>"},{"location":"inital_setup/#run-container","title":"Run Container","text":"<p><code>Important:</code> container need to have display access for gazebo gui, rviz gui <pre><code>xhost +\n</code></pre></p> <p>go inside the container <pre><code>docker exec -it gz-tutorial-container bash\n</code></pre></p>"},{"location":"inital_setup/#check-container","title":"Check Container","text":"<p>To check if container is running or not. Container name not in the list that means it not running <pre><code>docker ps\n</code></pre></p> <p>start <pre><code>docker start gz-tutorial-container\n</code></pre> stop <pre><code>docker stop gz-tutorial-container\n</code></pre></p>"},{"location":"inital_setup/#docker-volume-shared","title":"Docker Volume Shared","text":"<p>In <code>ros2-jazzy-gazebo-harmonic-docker/docker-compose.yaml</code> </p> <pre><code> volumes:\n      - /tmp/.X11-unix:/tmp/.X11-unix:rw\n      - ./gazebo-sim-plugins-tutorial/ros2_ws:/root/ros2_ws\n      - ./gazebo-sim-plugins-tutorial/standalone_gz_sim_plugins:/root/standalone_gz_sim_plugins\n</code></pre> <p><code>X11:</code> for display access  <code>ros2_ws</code>: entire ros2_ws is mounted inside root/ros2_ws. So any changes we make in ros2_ws will be reflected inside the container. <code>standalone_gz_sim_plugins</code> similary standalone_gz_sim_plugins is mounted inside root/standalone_gz_sim_plugins</p>"},{"location":"inital_setup/#troubleshooting","title":"Troubleshooting","text":"<p>GUI / Gazebo window not opening (Docker): - Ensure you ran: xhost + - Ensure DISPLAY is correctly passed into container (depends on your docker setup) - Display id is same in host &amp; container host &amp; docker container should have same <code>id</code> <pre><code>echo $DISPLAY\n</code></pre> output eg: <pre><code>$ echo $DISPLAY\n:0\n</code></pre></p> <p>if not export same display id in host &amp; docker container <pre><code>export DISPLAY=:0\n</code></pre></p>"},{"location":"joint-control-system-plugin/","title":"Joint Control System Plugin","text":"<p>We are goining to write a joint control system plugin to control one joint using 3 methods.</p> <p></p> <p>we will control <code>joint_1</code> </p> <p>using 3 methods: 1. Velocity 2. Force 3. Position</p>"},{"location":"joint-control-system-plugin/#1-find-the-joint-entity","title":"1. Find the Joint Entity","text":"<p>uing <code>EntityByComponents()</code></p> <p></p> <p>EntityComponentManager doc</p> <p>find such a joint entity which has all of the followings components:  \u00a0  \u00a0 \u00a0     parent entity is model component to which plugin is attached,  \u00a0 \u00a0 \u00a0      has a name component of value <code>joint_1</code> joint compenent is attach on it </p> <p>reference code</p> <pre><code>  this-&gt;jointEntity = _ecm.EntityByComponents(\n      components::ParentEntity(_entity),\n      components::Name(jointName),\n      components::Joint());\n</code></pre>"},{"location":"joint-control-system-plugin/#2-make-sure-plugin-attached-to-model-only","title":"2. Make Sure Plugin Attached To Model Only","text":"<pre><code>&lt;model&gt;\n\n....\n  &lt;plugin&gt;  .... &lt;/plugin&gt;\n\n&lt;/model&gt;\n</code></pre> <pre><code>if(!_ecm.EntityHasComponentType(_entity, components::Model::typeId)){\n    gzerr &lt;&lt; \"JointControl plugin must be added on &lt;model&gt;...&lt;/model&gt; scope only\" &lt;&lt; std::endl;\n    return;\n}\n</code></pre>"},{"location":"joint-control-system-plugin/#3-components-to-control-joint","title":"3. Components To Control Joint","text":"<p>List Of Component To Control Joint</p> <p>components doc</p> <p></p> <p>...<code>Cmd</code>: means component to command or write on it</p> <p>but position do have any direct <code>PositionCmd</code></p> <p>using 3 methods:</p>"},{"location":"joint-control-system-plugin/#1-velocity","title":"1. Velocity","text":"<p>using <code>components::JointVelocityCmd</code> </p> <p>unit: <code>radian/sec</code> for revolute joint </p> <p>data type: <code>vector&lt;double&gt;</code> </p> <pre><code>if (this-&gt;mode == Mode::Velocity)\n{\n    //if component is not preset than create it\n    if (!_ecm.EntityHasComponentType(this-&gt;jointEntity, components::JointVelocityCmd::typeId))\n        _ecm.CreateComponent(this-&gt;jointEntity, components::JointVelocityCmd({0.0}));\n\n    _ecm.SetComponentData&lt;components::JointVelocityCmd&gt;(this-&gt;jointEntity,\n                                                            {this-&gt;cmdVelocity});\n}\n</code></pre>"},{"location":"joint-control-system-plugin/#2-force","title":"2. Force:","text":"<p>using <code>components::JointForceCmd</code></p> <p>unit: <code>Nm</code> for revolute joint </p> <p>data type: <code>vector&lt;double&gt;</code> </p> <pre><code>else if (this-&gt;mode == Mode::Force){\n\n    //if component is not preset than create it\n    if (!_ecm.EntityHasComponentType(this-&gt;jointEntity, components::JointForceCmd::typeId))\n        _ecm.CreateComponent(this-&gt;jointEntity, components::JointForceCmd({0.0}));\n\n    _ecm.SetComponentData&lt;components::JointForceCmd&gt;(this-&gt;jointEntity,\n                                                            {this-&gt;cmdTorque});\n}\n</code></pre>"},{"location":"joint-control-system-plugin/#3-position","title":"3. Position","text":"<p>as there is no direct position cmd so will use <code>PD control</code>. Its a feedback loop control system very commandely used. good PID Simulator for understand PID.</p> <p></p> <p>will be using <code>components::JointForceCmd</code> to control torque using PD control</p> <pre><code>double error = this-&gt;targetPos - currentPos;\ndouble torque = this-&gt;pGain * error - this-&gt;dGain * currentVel;\n</code></pre> <p></p> <p>To Make Sure we are torque is within limit will set a min/max limit also stop applying torque once target is reached </p> <pre><code>double maxT = this-&gt;maxTorque;        \ndouble clamp_torque = std::clamp(torque, -maxT, maxT);\n\n//once reached within the tolerance will stop applying torque\nif(error &gt;= -pTolerance &amp;&amp; error &lt;= pTolerance){\n    clamp_torque = 0.0;\n}\n</code></pre> <p></p> <p>On time a fixed interval we want to switch between pos <code>A &lt;-&gt; B</code>  will use change target from A to B &amp; vise verse base on time</p> <pre><code>// on give time interval will switch target position\nauto elapsed = _info.simTime - this-&gt;lastSwitchTime;\nif (std::chrono::duration_cast&lt;std::chrono::seconds&gt;(elapsed).count() &gt;= this-&gt;waitTime)\n{\n    this-&gt;targetPos = (this-&gt;targetPos == this-&gt;posA) ? this-&gt;posB : this-&gt;posA;\n    this-&gt;lastSwitchTime = _info.simTime;\n    }\n</code></pre>"},{"location":"joint-control-system-plugin/#full-plugin","title":"Full Plugin","text":".sdf plugin part <pre><code>&lt;model&gt;\n....\n\n  &lt;plugin filename=\"JointControl\" name=\"gz::sim::JointControl\"&gt;\n    &lt;joint_name&gt;joint_1&lt;/joint_name&gt;\n\n    &lt;!-- posssible mode: \n          velocity\n          force\n          position\n    --&gt;\n    &lt;mode&gt;velocity&lt;/mode&gt;\n\n    &lt;!-- velocity mode (rad/sec)--&gt;\n    &lt;cmd_vel&gt;1.0&lt;/cmd_vel&gt;\n\n    &lt;!-- force mode (Nm)--&gt;\n    &lt;cmd_torque&gt;15.0&lt;/cmd_torque&gt;\n\n    &lt;!--position mode (radian)--&gt;\n    &lt;pos_a&gt;0.523599&lt;/pos_a&gt; &lt;!-- 30 deg--&gt;\n    &lt;pos_b&gt;2.0944&lt;/pos_b&gt; &lt;!-- 120 deg--&gt;\n    &lt;wait_time&gt;6&lt;/wait_time&gt;\n    &lt;!-- PD control--&gt;\n    &lt;p_gain&gt;10.0&lt;/p_gain&gt;\n    &lt;d_gain&gt;1.0&lt;/d_gain&gt;\n    &lt;max_torque&gt;10.0&lt;/max_torque&gt;\n    &lt;pos_tolerence&gt;0.1&lt;/pos_tolerence&gt;\n  &lt;/plugin&gt;\n\n&lt;/model&gt;\n</code></pre>   .hh file <pre><code>#ifndef JOINT_CONTROL_PLUGIN_HH_\n#define JOINT_CONTROL_PLUGIN_HH_\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n#include &lt;gz/sim/components/Joint.hh&gt;\n#include &lt;gz/sim/components/Model.hh&gt;\n#include &lt;gz/sim/components/ParentEntity.hh&gt;\n\n#include &lt;vector&gt;\n#include &lt;string&gt;\n\n\nenum class Mode\n{\n  Force,\n  Velocity,\n  Position\n};\n\nnamespace gz\n{\nnamespace sim\n{\nclass JointControl : public System, public ISystemConfigure,public ISystemPreUpdate\n{\npublic:\n  // Constructor\n  JointControl() = default;\n\n  void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n  // ISystemPreUpdate method\n  void PreUpdate(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nprivate:\n  // Function to find the light entity by name\n  std::string jointName; //joint name\n  Entity jointEntity; //joint entity\n\n  Mode mode{Mode::Velocity};\n  // Velocity mode\n  double cmdVelocity{0.0}; // for Velcoity Mode\n  double cmdTorque{0.0}; // for Force Mode\n  // Position mode: oscillate between 2 targets // Position Mode\n  double posA{0.0};\n  double posB{0.0};\n  int waitTime{1}; //time to wait from pos A-&gt;B\n  double targetPos{0.0}; // current target pose\n  bool hasInitTime{false}; // for init time\n  double pGain{50.0};  // P \n  double dGain{1.0};   // D\n  double maxTorque{10.0}; // max torque\n  double pTolerance{0.01}; // position tolerance \n  std::chrono::steady_clock::duration lastSwitchTime{0}; //last time when switching happended\n\n};\n}  // namespace sim\n}  // namespace gz\n\n#endif\n</code></pre>   .cc file <pre><code>#include \"tutorial_gazebo_plugins/JointControl.hh\"\n\n#include &lt;gz/plugin/Register.hh&gt;\n\n\n#include &lt;gz/sim/components/JointVelocityCmd.hh&gt;\n#include &lt;gz/sim/components/JointForceCmd.hh&gt;\n#include &lt;gz/sim/components/JointPosition.hh&gt;\n#include &lt;gz/sim/components/JointVelocity.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n\n#include &lt;algorithm&gt;  // for std::clamp\n\n\nusing namespace gz;\nusing namespace gz::sim;\n\nvoid JointControl::Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr)\n{\n  if (!_sdf-&gt;HasElement(\"joint_name\"))\n  {\n    gzerr &lt;&lt; \"JointControl plugin requires &lt;joint_name&gt;\" &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;jointName = _sdf-&gt;Get&lt;std::string&gt;(\"joint_name\");\n\n  if(!_ecm.EntityHasComponentType(_entity, components::Model::typeId)){\n    gzerr &lt;&lt; \"JointControl plugin must be added on &lt;model&gt;...&lt;/model&gt; scope only\" &lt;&lt; std::endl;\n    return;\n  }\n\n\n  if (_sdf-&gt;HasElement(\"mode\"))\n  {\n    const auto modeStr = _sdf-&gt;Get&lt;std::string&gt;(\"mode\");\n    if (modeStr == \"velocity\" || modeStr == \"vel\"){\n      this-&gt;mode = Mode::Velocity;\n      gzmsg &lt;&lt; \"Mode: Velocity\" &lt;&lt; std::endl;\n    }\n\n    else if(modeStr == \"force\" || modeStr == \"f\"){\n      this-&gt;mode = Mode::Force;\n      gzmsg &lt;&lt; \"Mode: Force\" &lt;&lt; std::endl;\n    }\n    else if (modeStr == \"position\" || modeStr == \"pos\"){\n      this-&gt;mode = Mode::Position;\n      gzmsg &lt;&lt; \"Mode: Position\" &lt;&lt; std::endl;\n    }\n    else\n      gzerr &lt;&lt; \"JointControl: unknown &lt;mode&gt; '\" &lt;&lt; modeStr\n            &lt;&lt; \"'. Using 'velocity'.\" &lt;&lt; std::endl;\n  }\n\n  if (_sdf-&gt;HasElement(\"cmd_vel\"))\n    this-&gt;cmdVelocity = _sdf-&gt;Get&lt;double&gt;(\"cmd_vel\");\n\n  if (_sdf-&gt;HasElement(\"cmd_torque\"))\n    this-&gt;cmdTorque = _sdf-&gt;Get&lt;double&gt;(\"cmd_torque\");\n\n  if (_sdf-&gt;HasElement(\"pos_a\"))\n    this-&gt;posA = _sdf-&gt;Get&lt;double&gt;(\"pos_a\");\n  if (_sdf-&gt;HasElement(\"pos_b\"))\n    this-&gt;posB = _sdf-&gt;Get&lt;double&gt;(\"pos_b\");\n\n  if (_sdf-&gt;HasElement(\"p_gain\"))\n    this-&gt;pGain = _sdf-&gt;Get&lt;double&gt;(\"p_gain\");\n\n  if (_sdf-&gt;HasElement(\"d_gain\"))\n    this-&gt;dGain = _sdf-&gt;Get&lt;double&gt;(\"d_gain\");\n\n  if (_sdf-&gt;HasElement(\"max_torque\"))\n    this-&gt;maxTorque = _sdf-&gt;Get&lt;double&gt;(\"max_torque\");\n\n  if (_sdf-&gt;HasElement(\"pos_tolerence\"))\n    this-&gt;pTolerance = _sdf-&gt;Get&lt;double&gt;(\"pos_tolerence\");\n\n  if (_sdf-&gt;HasElement(\"wait_time\"))\n    this-&gt;waitTime = _sdf-&gt;Get&lt;int&gt;(\"wait_time\");\n\n\n  /* find such a joint entity which has all of the followings components:\n        parent entity is model entity which plugin is attached to,\n        has a name component of joint name \n        joint compenent is attach on it\n        reference code: https://github.com/gazebosim/gz-sim/blob/gz-sim8/src/Model.cc#L132C1-L133C1\n  */\n  this-&gt;jointEntity = _ecm.EntityByComponents(\n      components::ParentEntity(_entity),\n      components::Name(jointName),\n      components::Joint());\n\n  this-&gt;targetPos = this-&gt;posA;   // start by going to posA\n  this-&gt;lastSwitchTime = std::chrono::steady_clock::duration::zero(); // or set on first PreUpdate\n}\n\n// ---------------------------------------------------------------------\nvoid JointControl::PreUpdate(const UpdateInfo &amp;_info,\n                             EntityComponentManager &amp;_ecm)\n{\n   if (_info.paused)\n    return;\n\n   if(!this-&gt;jointEntity)\n     return;\n\n\n  if (this-&gt;mode == Mode::Velocity)\n  {\n    if (!_ecm.EntityHasComponentType(this-&gt;jointEntity, components::JointVelocityCmd::typeId))\n      _ecm.CreateComponent(this-&gt;jointEntity, components::JointVelocityCmd({0.0}));\n\n    _ecm.SetComponentData&lt;components::JointVelocityCmd&gt;(this-&gt;jointEntity,\n                                                          {this-&gt;cmdVelocity});\n  }\n\n  else if (this-&gt;mode == Mode::Force){\n\n    //if component is not preset than create it\n    if (!_ecm.EntityHasComponentType(this-&gt;jointEntity, components::JointForceCmd::typeId))\n      _ecm.CreateComponent(this-&gt;jointEntity, components::JointForceCmd({0.0}));\n\n    _ecm.SetComponentData&lt;components::JointForceCmd&gt;(this-&gt;jointEntity,\n                                                          {this-&gt;cmdTorque});\n  }\n\n\n  else if (this-&gt;mode == Mode::Position){\n\n    if (!this-&gt;hasInitTime)\n    {\n      this-&gt;lastSwitchTime = _info.simTime;\n      this-&gt;hasInitTime = true;\n    }\n\n\n    // on give time interval will switch target position\n    auto elapsed = _info.simTime - this-&gt;lastSwitchTime;\n    if (std::chrono::duration_cast&lt;std::chrono::seconds&gt;(elapsed).count() &gt;= this-&gt;waitTime)\n    {\n      this-&gt;targetPos = (this-&gt;targetPos == this-&gt;posA) ? this-&gt;posB : this-&gt;posA;\n      this-&gt;lastSwitchTime = _info.simTime;\n    }\n\n    //read current position\n    auto posComp = _ecm.Component&lt;components::JointPosition&gt;(this-&gt;jointEntity);\n    if (!posComp)\n    {\n      _ecm.CreateComponent(this-&gt;jointEntity, components::JointPosition());\n      gzdbg &lt;&lt; \"JointPosition component missing\\n\";\n      return;\n    }\n    if (posComp-&gt;Data().empty())\n    {\n      gzdbg &lt;&lt; \"JointPosition data empty\\n\";\n      return;\n    }\n    double currentPos = posComp-&gt;Data()[0];\n\n    // Current velocity\n    auto velComp = _ecm.Component&lt;components::JointVelocity&gt;(this-&gt;jointEntity);\n    if (!velComp)\n    {\n      _ecm.CreateComponent(this-&gt;jointEntity, components::JointVelocity());\n      gzdbg &lt;&lt; \"JointPosition component missing\\n\";\n      return;\n    }\n    double currentVel = velComp-&gt;Data()[0];\n\n    // PD control\n    double error = this-&gt;targetPos - currentPos;\n    double torque = this-&gt;pGain * error - this-&gt;dGain * currentVel;\n\n    double maxT = this-&gt;maxTorque;        \n    double clamp_torque = std::clamp(torque, -maxT, maxT);\n\n    //once reached within the tolerance will stop applying torque\n    if(error &gt;= -pTolerance &amp;&amp; error &lt;= pTolerance){\n      clamp_torque = 0.0;\n    }\n\n    // ensure force cmd exists (if you didn\u2019t create in Configure)\n    if (!_ecm.EntityHasComponentType(this-&gt;jointEntity, components::JointForceCmd::typeId))\n      _ecm.CreateComponent(this-&gt;jointEntity, components::JointForceCmd({0.0}));\n\n    _ecm.SetComponentData&lt;components::JointForceCmd&gt;(this-&gt;jointEntity, {clamp_torque});\n    gzmsg &lt;&lt; \"pos target=\" &lt;&lt; this-&gt;targetPos &lt;&lt; \" cur=\" &lt;&lt; currentPos\n          &lt;&lt; \" torque=\" &lt;&lt; clamp_torque &lt;&lt; std::endl;\n\n  }\n\n}\n\n// Register the plugin\nGZ_ADD_PLUGIN(\n    JointControl,\n    gz::sim::System,\n    JointControl::ISystemConfigure,\n    JointControl::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(JointControl, \"gz::sim::JointControl\")\n</code></pre>"},{"location":"light-control-direct-ros-plugin/","title":"LightControlDirectROS Plugin","text":"<p>We are going to use rclcpp to control light on/off same system plugin as LightControl Plugin by ros2 service of type <code>std_srvs/srv/Trigger</code></p> <p></p> <p> </p>"},{"location":"light-control-direct-ros-plugin/#why-cant-we-use-gz-ros-bridge","title":"Why Can't We Use gz-ros-bridge?","text":"<p>there are only limited set of msg supported for ros gz brige. <code>Empty msg</code> service is not added yet.</p> <p></p> <p>more here details here in the doc list of supported msg</p>"},{"location":"light-control-direct-ros-plugin/#threading","title":"Threading","text":"<p>threading logic is extact same with [MoveModelDirectRos] Plugin move-model-direct-ros-plugin.md</p> <pre><code>// --- ROS 2 Initialization ---\n// Initialize ROS 2 (safe to call multiple times)\nif (!rclcpp::ok())\n{\n// Pass in dummy arguments.\nrclcpp::init(0, nullptr); \n}\n\n// Create the ROS 2 node\nthis-&gt;ros_node_ = std::make_shared&lt;rclcpp::Node&gt;(\"gz_light_control_ros_plugin\");\n// this-&gt;executor_ = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;();\nthis-&gt;ros_executor_ = std::make_shared&lt;rclcpp::executors::SingleThreadedExecutor&gt;();\nthis-&gt;ros_executor_-&gt;add_node(this-&gt;ros_node_);\n\n//lamda function having ros spin\nauto ros_thread_spin = [this]() \n{ \nthis-&gt;ros_executor_-&gt;spin(); \n};\n\n//make a new thread for ros spin\nthis-&gt;cpp_thread = std::thread(ros_thread_spin);\n</code></pre>"},{"location":"light-control-direct-ros-plugin/#code","title":"Code","text":"<p>entire code is same just we added ros2 service </p> <pre><code>// Create ROS 2 service using the same name from SDF, e.g. \"/lights_on_srv\"\n  this-&gt;ros_srv_ = this-&gt;ros_node_-&gt;create_service&lt;std_srvs::srv::Trigger&gt;(\n    this-&gt;serviceName,\n    std::bind(&amp;LightControlDirectRos::RosToggleCallback,\n              this,\n              std::placeholders::_1,\n              std::placeholders::_2));\n</code></pre> <p>callback function <pre><code>void LightControlDirectRos::RosToggleCallback(\n    const std::shared_ptr&lt;std_srvs::srv::Trigger::Request&gt; /*req*/,\n    std::shared_ptr&lt;std_srvs::srv::Trigger::Response&gt; res)\n{\n  // Flip state and indicate that PreUpdate must apply this change once\n  this-&gt;isLightOn = !this-&gt;isLightOn;\n  this-&gt;pendingApply = true;\n\n  gzmsg &lt;&lt; \"[LightControlDirectRos] ROS toggle. isLightOn = \"\n        &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n\n  res-&gt;success = true;\n  res-&gt;message = this-&gt;isLightOn ? \"Light turned ON\" : \"Light turned OFF\";\n}\n</code></pre></p>"},{"location":"light-control-direct-ros-plugin/#full-plugin","title":"Full Plugin","text":".sdf plugin part <pre><code>&lt;plugin\n    filename=\"LightControlDirectRos\"\n    name=\"gz::sim::LightControlDirectRos\"&gt;\n\n    &lt;on_off_ros_service_name&gt;lights_on_srv&lt;/on_off_ros_service_name&gt;\n&lt;/plugin&gt;\n</code></pre>  .hh <pre><code>#ifndef LIGHT_CONTROL_ROS_PLUGIN_HH_\n#define LIGHT_CONTROL_ROS_PLUGIN_HH_\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/math/Color.hh&gt;\n#include &lt;gz/sim/Light.hh&gt;\n\n#include &lt;gz/msgs.hh&gt;\n#include &lt;gz/transport.hh&gt;\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;std_srvs/srv/trigger.hpp&gt;\n#include &lt;thread&gt;\n\n\n#include &lt;vector&gt;\n\nnamespace gz\n{\nnamespace sim\n{\nclass LightControlDirectRos : public System, public ISystemPreUpdate, public ISystemConfigure\n{\npublic:\n  // Constructor\n  LightControlDirectRos() = default;\n\n  void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n  // ISystemPreUpdate method\n  void PreUpdate(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nprivate:\n  // Function to find the light entity by name\n  void FindLightEntities(EntityComponentManager &amp;_ecm);\n\n  //empty service call to turn on/off light\n  void RosToggleCallback(\n      const std::shared_ptr&lt;std_srvs::srv::Trigger::Request&gt; req,\n      std::shared_ptr&lt;std_srvs::srv::Trigger::Response&gt; res);\n\n  // Time accumulator for color cycling\n  double time = 0.0;\n\n  std::vector&lt;Entity&gt; lightEntities; //list of light entity\n\n  gz::transport::Node node; //gz node\n  std::string serviceName; //service name\n  bool isLightOn; //val for light on/off\n  bool pendingApply{false};   // apply state change once (e.g., when toggled OFF)\n\n\n   // ROS 2 Members\n  rclcpp::Node::SharedPtr ros_node_;\n  rclcpp::Service&lt;std_srvs::srv::Trigger&gt;::SharedPtr ros_srv_; \n  // rclcpp::executors::MultiThreadedExecutor::SharedPtr executor_\n  rclcpp::executors::SingleThreadedExecutor::SharedPtr ros_executor_; //Executor to spin the controller\n  std::thread cpp_thread; //std thread to make new thread\n};\n}  // namespace sim\n}  // namespace gz\n\n#endif\n</code></pre>  .cc <pre><code>#include \"tutorial_gazebo_plugins/LightControlDirectRos.hh\"\n\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\n#include &lt;gz/common/Console.hh&gt;\n\n#include &lt;gz/transport/Node.hh&gt;\n#include &lt;gz/msgs/empty.pb.h&gt;\n#include &lt;gz/msgs/light.pb.h&gt;\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/Types.hh&gt;\n#include &lt;gz/sim/Entity.hh&gt;\n#include &lt;gz/sim/EntityComponentManager.hh&gt;\n#include &lt;gz/sim/EventManager.hh&gt;\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/sim/components/LightCmd.hh&gt;\n#include &lt;gz/sim/Conversions.hh&gt;\n#include &lt;gz/math/Color.hh&gt;\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\n\n#include &lt;rclcpp/executors.hpp&gt; // New: ROS 2 includes\n\n\nusing namespace gz;\nusing namespace gz::sim;\n\n//////////////////////////////////////////////////\nvoid LightControlDirectRos::Configure(const Entity &amp;/*_entity*/,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;/*_ecm*/,\n    EventManager &amp;/*_eventMgr*/)\n{\n  if (!_sdf || !_sdf-&gt;HasElement(\"on_off_ros_service_name\"))\n  {\n    gzerr &lt;&lt; \"LightControlDirectRos plugin requires &lt;on_off_ros_service_name&gt;.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;serviceName = _sdf-&gt;Get&lt;std::string&gt;(\"on_off_ros_service_name\");\n\n\n  // Initial state\n  this-&gt;isLightOn = true;\n  this-&gt;pendingApply = true;  // push initial state to the world once\n\n\n  // --- ROS 2 Initialization ---\n  // Initialize ROS 2 (safe to call multiple times)\n  if (!rclcpp::ok())\n  {\n    // Pass in dummy arguments.\n    rclcpp::init(0, nullptr); \n  }\n\n  // ### Explanation ###\n  /*\n\n  ros executor code snap:\n    rclcpp::executors::SingleThreadedExecutor executor;\n    executor.add_node(node);\n    executor.spin();  // blocks this thread, one callback at a time\n\n  gz main thread:\n  ------\n\n  in loop:\n   PreUpdate()     -&gt; using ros spin (executor.spin()) in main thread  will block gazebo sim\n   Update()       \n   PostUpdate()\n\n\n   solution:\n\n   main gz thread                  ---&gt;(make another thread for ros)  using std::thread \n   ------                           |\n                                    |    -&gt; ros spin work with blocking but not harm gz main thread \n  in loop:                          |        as it a different thread\n   PreUpdate()    -&gt; no blocking    |    \n   Update()                         |    -&gt; std::thread -&gt; make new thread cpp_thread having ros_executor-&gt;spin()\n   PostUpdate()                     |  \n\n  */\n\n  // Create the ROS 2 node\n  this-&gt;ros_node_ = std::make_shared&lt;rclcpp::Node&gt;(\"gz_light_control_ros_plugin\");\n  // this-&gt;executor_ = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;();\n  this-&gt;ros_executor_ = std::make_shared&lt;rclcpp::executors::SingleThreadedExecutor&gt;();\n  this-&gt;ros_executor_-&gt;add_node(this-&gt;ros_node_);\n\n  //lamda function having ros spin\n  auto ros_thread_spin = [this]() \n  { \n    this-&gt;ros_executor_-&gt;spin(); \n  };\n\n  //make a new thread for ros spin\n  this-&gt;cpp_thread = std::thread(ros_thread_spin);\n\n  // Create ROS 2 service using the same name from SDF, e.g. \"/lights_on_srv\"\n  this-&gt;ros_srv_ = this-&gt;ros_node_-&gt;create_service&lt;std_srvs::srv::Trigger&gt;(\n    this-&gt;serviceName,\n    std::bind(&amp;LightControlDirectRos::RosToggleCallback,\n              this,\n              std::placeholders::_1,\n              std::placeholders::_2));\n\n}\n\n//////////////////////////////////////////////////\nvoid LightControlDirectRos::RosToggleCallback(\n    const std::shared_ptr&lt;std_srvs::srv::Trigger::Request&gt; /*req*/,\n    std::shared_ptr&lt;std_srvs::srv::Trigger::Response&gt; res)\n{\n  // Flip state and indicate that PreUpdate must apply this change once\n  this-&gt;isLightOn = !this-&gt;isLightOn;\n  this-&gt;pendingApply = true;\n\n  gzmsg &lt;&lt; \"[LightControlDirectRos] ROS toggle. isLightOn = \"\n        &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n\n  res-&gt;success = true;\n  res-&gt;message = this-&gt;isLightOn ? \"Light turned ON\" : \"Light turned OFF\";\n}\n\n//////////////////////////////////////////////////\nvoid LightControlDirectRos::FindLightEntities(EntityComponentManager &amp;_ecm)\n{\n  this-&gt;lightEntities.clear();\n  _ecm.Each&lt;components::Light&gt;(\n      [&amp;](const Entity &amp;_e, const components::Light *) -&gt; bool\n      {\n        this-&gt;lightEntities.push_back(_e);\n        return true;\n      });\n}\n\n//////////////////////////////////////////////////\nvoid LightControlDirectRos::PreUpdate(const UpdateInfo &amp;_info,\n                                     EntityComponentManager &amp;_ecm)\n{\n  if (_info.paused)\n    return;\n\n  // Only advance animation time while ON\n  if (this-&gt;isLightOn)\n  {\n    this-&gt;time += std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(\n                         _info.dt).count();\n  }\n\n  this-&gt;FindLightEntities(_ecm);\n  if (this-&gt;lightEntities.empty())\n    return;\n\n  // Color for ON animation (computed only if ON)\n  gz::math::Color animColor(1, 1, 1, 1);\n  if (this-&gt;isLightOn)\n  {\n    const double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5));\n    const double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0));\n    const double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0));\n    animColor = gz::math::Color(r, g, b, 1.0);\n  }\n\n  for (const Entity e : this-&gt;lightEntities)\n  {\n    // When OFF and no state change to apply, do nothing at all\n    if (!this-&gt;isLightOn &amp;&amp; !this-&gt;pendingApply)\n      continue;\n\n    auto lightComp = _ecm.Component&lt;components::Light&gt;(e);\n    if (!lightComp)\n      continue;\n\n    // Start from current SDF, then apply our command\n    const sdf::v14::Light &amp;sdfLight = lightComp-&gt;Data();\n    gz::msgs::Light msg = gz::sim::convert&lt;gz::msgs::Light&gt;(sdfLight);\n\n    if (this-&gt;isLightOn)\n    {\n      // While ON: animate color every tick and ensure light is enabled\n      gz::msgs::Set(msg.mutable_diffuse(),  animColor);\n      gz::msgs::Set(msg.mutable_specular(), animColor);\n      msg.set_is_light_off(false);\n      // Intensity left as configured by SDF; can be animated if desired\n    }\n    else\n    {\n      // Transitioning to OFF: send ONCE, then stop publishing\n      msg.set_is_light_off(true);\n      msg.set_intensity(0.0);   // defensive: ensure no residual emission\n    }\n\n    _ecm.SetComponentData&lt;components::LightCmd&gt;(e, msg);\n    _ecm.SetChanged(e, components::LightCmd::typeId,\n                    ComponentState::PeriodicChange);\n  }\n\n  if (!this-&gt;isLightOn &amp;&amp; this-&gt;pendingApply)\n    this-&gt;pendingApply = false;\n\n}\n\n// --- Plugin registration ---\nGZ_ADD_PLUGIN(\n  gz::sim::LightControlDirectRos,\n  gz::sim::System,\n  gz::sim::LightControlDirectRos::ISystemConfigure,\n  gz::sim::LightControlDirectRos::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::LightControlDirectRos,\n                    \"gz::sim::LightControlDirectRos\")\n</code></pre>"},{"location":"light-control-direct-ros-plugin/#build-run","title":"Build &amp; Run","text":"<p>build <pre><code>cd ros2_ws\ncolcon build --symlink-install\nsource install/setup.bash\n</code></pre></p> <p>run <pre><code>ros2 launch yt_tutorial_gazebo_ros light_control_direct_ros.launch.py\n</code></pre></p> <p>service call <pre><code>ros2 service call /lights_on_srv std_srvs/srv/Trigger {}\n</code></pre></p>"},{"location":"light-control-service-way-plugin/","title":"Light Control Service Way System Plugin","text":"<p>In the last plugin of Light Control Plugin will added <code>gz service</code> to turn light on/off. Same way as earlier we are using <code>gz-transport</code> for service/client.</p> <p></p> <p>here we are going to send service call request on type empty to gz-transport server.</p> <p> </p> <p>gazebo transport  - Services c++ example - Services python example</p>"},{"location":"light-control-service-way-plugin/#plugin","title":"Plugin","text":".sdf plugin part <pre><code>&lt;plugin\n    filename=\"LightControlServiceWay\"\n    name=\"gz::sim::LightControlServiceWay\"&gt;\n\n    &lt;on_off_service_name&gt;lights_on_srv&lt;/on_off_service_name&gt;\n&lt;/plugin&gt;\n</code></pre> .hh file <pre><code>#ifndef LIGHT_CONTROL_PLUGIN_HH_\n#define LIGHT_CONTROL_PLUGIN_HH_\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/math/Color.hh&gt;\n#include &lt;gz/sim/Light.hh&gt;\n\n#include &lt;gz/msgs.hh&gt;\n#include &lt;gz/transport.hh&gt;\n\n\n#include &lt;vector&gt;\n\nnamespace gz\n{\nnamespace sim\n{\nclass LightControlServiceWay : public System, public ISystemPreUpdate, public ISystemConfigure\n{\npublic:\n  // Constructor\n  LightControlServiceWay() = default;\n\n  void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n  // ISystemPreUpdate method\n  void PreUpdate(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nprivate:\n  // Function to find the light entity by name\n  void FindLightEntities(EntityComponentManager &amp;_ecm);\n\n  //empty service call to turn on/off light\n  bool srvLightToggle(const gz::msgs::Empty &amp;_req,\n  gz::msgs::Empty &amp;_rep);\n\n  // Time accumulator for color cycling\n  double time = 0.0;\n\n  std::vector&lt;Entity&gt; lightEntities; //list of light entity\n\n  gz::transport::Node node; //gz node\n  std::string serviceName; //service name\n  bool isLightOn; //val for light on/off\n  bool pendingApply{false};   // apply state change once (e.g., when toggled OFF)\n};\n}  // namespace sim\n}  // namespace gz\n\n#endif\n</code></pre> .cc file <pre><code>#include \"tutorial_gazebo_plugins/LightControlServiceWay.hh\"\n\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;iostream&gt;\n\n#include &lt;gz/common/Console.hh&gt;\n\n#include &lt;gz/transport/Node.hh&gt;\n#include &lt;gz/msgs/empty.pb.h&gt;\n#include &lt;gz/msgs/light.pb.h&gt;\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/Types.hh&gt;\n#include &lt;gz/sim/Entity.hh&gt;\n#include &lt;gz/sim/EntityComponentManager.hh&gt;\n#include &lt;gz/sim/EventManager.hh&gt;\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/sim/components/LightCmd.hh&gt;\n#include &lt;gz/sim/Conversions.hh&gt;\n#include &lt;gz/math/Color.hh&gt;\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\n\nusing namespace gz;\nusing namespace gz::sim;\n\n//////////////////////////////////////////////////\nvoid LightControlServiceWay::Configure(const Entity &amp;/*_entity*/,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;/*_ecm*/,\n    EventManager &amp;/*_eventMgr*/)\n{\n  if (!_sdf || !_sdf-&gt;HasElement(\"on_off_service_name\"))\n  {\n    gzerr &lt;&lt; \"LightControlServiceWay plugin requires &lt;on_off_service_name&gt;.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;serviceName = _sdf-&gt;Get&lt;std::string&gt;(\"on_off_service_name\");\n\n\n  // Initial state\n  this-&gt;isLightOn = true;\n  this-&gt;pendingApply = true;  // push initial state to the world once\n\n\n  // Advertise service: Empty -&gt; Empty, callback returns bool\n  bool ok = this-&gt;node.Advertise(\n      this-&gt;serviceName,\n      &amp;LightControlServiceWay::srvLightToggle,\n      this);\n\n  if (!ok)\n  {\n    std::cerr &lt;&lt; \"Error advertising service [\" &lt;&lt; this-&gt;serviceName &lt;&lt; \"]\"\n              &lt;&lt; std::endl;\n  }\n\n   gzmsg &lt;&lt; \"[LightControlServiceWay] Service Name: \"\n        &lt;&lt; this-&gt;serviceName &lt;&lt; std::endl;\n\n\n}\n\n//////////////////////////////////////////////////\nbool LightControlServiceWay::srvLightToggle(\n    const gz::msgs::Empty &amp;/*_req*/, gz::msgs::Empty &amp;/*_rep*/)\n{\n  // Flip state and mark that we must push a single command if turning OFF\n  this-&gt;isLightOn = !this-&gt;isLightOn;\n  this-&gt;pendingApply = true;\n\n  gzmsg &lt;&lt; \"[LightControlServiceWay] Toggled. isLightOn = \" &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n\n  std::cerr &lt;&lt; \"[LightControlServiceWay] Toggled. isLightOn = \"\n        &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n  return true;\n}\n\n//////////////////////////////////////////////////\nvoid LightControlServiceWay::FindLightEntities(EntityComponentManager &amp;_ecm)\n{\n  this-&gt;lightEntities.clear();\n  _ecm.Each&lt;components::Light&gt;(\n      [&amp;](const Entity &amp;_e, const components::Light *) -&gt; bool\n      {\n        this-&gt;lightEntities.push_back(_e);\n        return true;\n      });\n}\n\n//////////////////////////////////////////////////\nvoid LightControlServiceWay::PreUpdate(const UpdateInfo &amp;_info,\n                                     EntityComponentManager &amp;_ecm)\n{\n  if (_info.paused)\n    return;\n\n  // Only advance animation time while ON\n  if (this-&gt;isLightOn)\n  {\n    this-&gt;time += std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(\n                         _info.dt).count();\n  }\n\n  this-&gt;FindLightEntities(_ecm);\n  if (this-&gt;lightEntities.empty())\n    return;\n\n  // Color for ON animation (computed only if ON)\n  gz::math::Color animColor(1, 1, 1, 1);\n  if (this-&gt;isLightOn)\n  {\n    const double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5));\n    const double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0));\n    const double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0));\n    animColor = gz::math::Color(r, g, b, 1.0);\n  }\n\n  for (const Entity e : this-&gt;lightEntities)\n  {\n    // When OFF and no state change to apply, do nothing at all\n    if (!this-&gt;isLightOn &amp;&amp; !this-&gt;pendingApply)\n      continue;\n\n    auto lightComp = _ecm.Component&lt;components::Light&gt;(e);\n    if (!lightComp)\n      continue;\n\n    // Start from current SDF, then apply our command\n    const sdf::v14::Light &amp;sdfLight = lightComp-&gt;Data();\n    gz::msgs::Light msg = gz::sim::convert&lt;gz::msgs::Light&gt;(sdfLight);\n\n    if (this-&gt;isLightOn)\n    {\n      // While ON: animate color every tick and ensure light is enabled\n      gz::msgs::Set(msg.mutable_diffuse(),  animColor);\n      gz::msgs::Set(msg.mutable_specular(), animColor);\n      msg.set_is_light_off(false);\n      // Intensity left as configured by SDF; can be animated if desired\n    }\n    else\n    {\n      // Transitioning to OFF: send ONCE, then stop publishing\n      msg.set_is_light_off(true);\n      msg.set_intensity(0.0);   // defensive: ensure no residual emission\n    }\n\n    _ecm.SetComponentData&lt;components::LightCmd&gt;(e, msg);\n    _ecm.SetChanged(e, components::LightCmd::typeId,\n                    ComponentState::PeriodicChange);\n  }\n\n  if (!this-&gt;isLightOn &amp;&amp; this-&gt;pendingApply)\n    this-&gt;pendingApply = false;\n\n}\n\n// --- Plugin registration ---\nGZ_ADD_PLUGIN(\n  gz::sim::LightControlServiceWay,\n  gz::sim::System,\n  gz::sim::LightControlServiceWay::ISystemConfigure,\n  gz::sim::LightControlServiceWay::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::LightControlServiceWay,\n                    \"gz::sim::LightControlServiceWay\")\n</code></pre>"},{"location":"light-control-service-way-plugin/#gazebo-messages","title":"Gazebo Messages","text":"<p>gz-msgs github</p> <p>gz-msgs use google Protobuf messages</p> <p></p> <p>gz msgs Empty Class Reference</p> <p></p> <p> </p>"},{"location":"light-control-service-way-plugin/#gazebo-transport-node","title":"Gazebo Transport Node","text":"<p>transport class api</p> <p></p> <pre><code> gz::transport::Node node; // GZ Transport node\n</code></pre> <p></p> <p></p> <pre><code>// Advertise service: Empty -&gt; Empty, callback returns bool\nbool ok = this-&gt;node.Advertise(\n    this-&gt;serviceName,\n    &amp;LightControlServiceWay::srvLightToggle,\n    this);\n\nif (!ok)\n{\nstd::cerr &lt;&lt; \"Error advertising service [\" &lt;&lt; this-&gt;serviceName &lt;&lt; \"]\"\n            &lt;&lt; std::endl;\n}\n</code></pre> <p> </p> <p>service callback</p> <pre><code>bool LightControlServiceWay::srvLightToggle(\n    const gz::msgs::Empty &amp;/*_req*/, gz::msgs::Empty &amp;/*_rep*/)\n{\n  // Flip state and mark that we must push a single command if turning OFF\n  this-&gt;isLightOn = !this-&gt;isLightOn;\n  this-&gt;pendingApply = true;\n\n  gzmsg &lt;&lt; \"[LightControlServiceWay] Toggled. isLightOn = \" &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n\n  std::cerr &lt;&lt; \"[LightControlServiceWay] Toggled. isLightOn = \"\n        &lt;&lt; std::boolalpha &lt;&lt; this-&gt;isLightOn &lt;&lt; std::endl;\n  return true;\n}\n</code></pre>"},{"location":"light-control-service-way-plugin/#variable","title":"Variable","text":"<p><code>isLightOn:</code> toggle base on when light is on or off  <code>pendingApply:</code> until light off is pending its true once done it becomes false </p>"},{"location":"light-control-service-way-plugin/#gz-service","title":"Gz Service","text":"<p>gazebo service list <pre><code>gz service -l\n</code></pre></p> <p>To check topic <pre><code>gz service -i -s /lights_on_srv\n</code></pre></p> <p></p> <p>To send comand to light Empty service <pre><code>gz service -s /lights_on_srv   --reqtype gz.msgs.Empty   --reptype gz.msgs.Empty   --req ''\n</code></pre></p>"},{"location":"light-control-system-plugin/","title":"Light Control System Plugin","text":"<p>In this tutorial we make a light control system plugin. Will use 2 spot light to make disco light effect</p> <p></p> <p></p>"},{"location":"light-control-system-plugin/#light-control-logic","title":"Light Control Logic","text":"<ul> <li>Read the 2 light component current value</li> <li>change only the <code>diffuse &amp; specular</code> colour rgb value</li> <li>Update the colours on every loop</li> </ul>"},{"location":"light-control-system-plugin/#how-colour-change-works","title":"How Colour Change works","text":"<p>graph link</p> <p></p> <pre><code>    // Animated RGB in [0,1]\n    const double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5));\n    const double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0));\n    const double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0));\n    gz::math::Color newColor(r, g, b, 1.0);\n</code></pre> <p> </p>"},{"location":"light-control-system-plugin/#how-to-get-multiple-entities","title":"How To Get Multiple Entities","text":"<p>related api in  EntityComponentManager class</p> <pre><code>//check for such components which has Light, Name components\n_ecm.Each&lt;components::Light, components::Name&gt;(\n    [&amp;](const Entity &amp;_entity,\n        const components::Light *,\n        const components::Name *_name) -&gt; bool\n    {\n    this-&gt;lightEntites.push_back(_entity);\n    // gzmsg &lt;&lt; \"Found light: \" &lt;&lt; _name-&gt;Data()\n    //       &lt;&lt; \" (entity \" &lt;&lt; _entity &lt;&lt; \")\\n\";\n    return true;\n    });\n</code></pre> <p> </p>"},{"location":"light-control-system-plugin/#update-component-values","title":"Update Component Values","text":"<p>lets first see the all available components for light</p> <p></p> <p><code>LightCmd</code> has <code>Cmd</code> we can use it command/control the light plugin </p> <p></p>"},{"location":"light-control-system-plugin/#convert-data-type","title":"Convert Data Type","text":"<p>what is the data type of it? </p> <p><code>components::Light</code> -  <code>sdf::Light</code> data type  <code>components::LightCmd</code> - <code>gz::msgs::Light</code> data type </p> <p>both has a different data type means we need to convert between them</p> <p></p> <p>related api in gz::sim ,gz::msgs api</p> <pre><code>auto lightComp = _ecm.Component&lt;components::Light&gt;(e);\nconst sdf::v14::Light &amp;sdfLight = lightComp-&gt;Data();\n\n//convert sdf light msg to gz light msg\ngz::msgs::Light msg = gz::sim::convert&lt;gz::msgs::Light&gt;(sdfLight);\n</code></pre> <p> </p>"},{"location":"light-control-system-plugin/#set-new-colour","title":"Set New Colour","text":"<p>Inside gz::sim::light class</p> <p>diffuses &amp; specular both msg are of type <code>gz::msgs::Color</code></p> <pre><code>gz::math::Color newColor(r, g, b, 1.0);\n\n//using Set() to set the fields of light msg\ngz::msgs::Set(msg.mutable_diffuse(),  newColor);\ngz::msgs::Set(msg.mutable_specular(), newColor);\n</code></pre> <p></p> <p></p> <p>that is why we can use <code>gz::msgs::Set()</code>  to set <code>gz::math::Color</code> values</p> <p></p> <p> set the LightCmd Component, its same method that we dicussed in MoveModel System Plugin</p> <pre><code>//method1\n// auto cmdComp = _ecm.Component&lt;components::LightCmd&gt;(e);\n// if (!cmdComp)\n//   _ecm.CreateComponent(e, components::LightCmd(msg));\n// else\n// {\n\n//   cmdComp-&gt;Data() = msg;\n\n\n// }\n\n//method2\n_ecm.SetComponentData&lt;components::LightCmd&gt;(e,msg);\n</code></pre> <p>in case of light we need to trigger update so that rendering system knows it updated but it case of all physics related plugin it auto updates like in case of Move Model velocity get auto updated.</p> <pre><code>    _ecm.SetChanged(e,\n                    components::LightCmd::typeId,\n                    ComponentState::PeriodicChange);\n                    /// PeriodicChange -&gt;changing periodically,ok to drop few samples\n</code></pre> <p></p>"},{"location":"light-control-system-plugin/#full-plugin","title":"Full Plugin","text":"plugin .sdf file <pre><code>&lt;!-- custom plugin to make disco light effect--&gt;\n&lt;plugin\n    filename=\"LightControl\"\n    name=\"gz::sim::LightControl\"&gt;\n&lt;/plugin&gt;\n</code></pre> .hh file <pre><code>#ifndef LIGHT_CONTROL_PLUGIN_HH_\n#define LIGHT_CONTROL_PLUGIN_HH_\n\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/math/Color.hh&gt;\n#include &lt;gz/sim/Light.hh&gt;\n\n#include &lt;vector&gt;\n\nnamespace gz\n{\nnamespace sim\n{\nclass LightControl : public System, public ISystemPreUpdate\n{\npublic:\n  // Constructor\n  LightControl() = default;\n\n  // ISystemPreUpdate method\n  void PreUpdate(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nprivate:\n  // Function to find the light entity by name\n  void FindLightEntities(EntityComponentManager &amp;_ecm);\n\n  // Time accumulator for color cycling\n  double time = 0.0;\n\n  std::vector&lt;Entity&gt; lightEntites; //list of light entity\n};\n}  // namespace sim\n}  // namespace gz\n\n#endif\n</code></pre> .cc file <pre><code>#include \"tutorial_gazebo_plugins/LightControl.hh\"\n\n#include &lt;gz/plugin/Register.hh&gt;\n\n#include &lt;gz/msgs/light.pb.h&gt;\n#include &lt;gz/msgs/Utility.hh&gt;\n\n#include &lt;gz/sim/components/Light.hh&gt;\n#include &lt;gz/sim/components/LightCmd.hh&gt;\n#include &lt;gz/sim/components/Name.hh&gt;\n\n#include &lt;sdf/Light.hh&gt;\n#include &lt;gz/sim/Conversions.hh&gt;\n\n\nusing namespace gz;\nusing namespace gz::sim;\n\n\n// Find all light entities\nvoid LightControl::FindLightEntities(EntityComponentManager &amp;_ecm)\n{\n  this-&gt;lightEntites.clear();\n\n\n  //check for such components which has Light, Name components\n  _ecm.Each&lt;components::Light, components::Name&gt;(\n      [&amp;](const Entity &amp;_entity,\n          const components::Light *,\n          const components::Name *_name) -&gt; bool\n      {\n        this-&gt;lightEntites.push_back(_entity);\n        // gzmsg &lt;&lt; \"Found light: \" &lt;&lt; _name-&gt;Data()\n        //       &lt;&lt; \" (entity \" &lt;&lt; _entity &lt;&lt; \")\\n\";\n        return true;\n      });\n}\n\n// ---------------------------------------------------------------------\nvoid LightControl::PreUpdate(const UpdateInfo &amp;_info,\n                             EntityComponentManager &amp;_ecm)\n{\n   if (_info.paused)\n    return;\n\n  this-&gt;time += std::chrono::duration_cast&lt;std::chrono::duration&lt;double&gt;&gt;(\n                    _info.dt)\n                    .count();\n\n  this-&gt;FindLightEntities(_ecm);\n  if (this-&gt;lightEntites.empty())\n    return;\n\n  //Un comment to see the flicker effect\n  // Flicker (no RNG): irregular brightness 0.15..1.0\n  // constexpr double kTwoPi = 6.283185307179586;\n  // const double t = this-&gt;time;\n\n  // double flicker = 0.55\n  //   + 0.25 * std::sin(kTwoPi * 17.0 * t)\n  //   + 0.15 * std::sin(kTwoPi * 23.0 * t + 1.7)\n  //   + 0.10 * std::sin(kTwoPi * 31.0 * t + 0.3);\n\n\n  // flicker = std::clamp(flicker, 0.15, 1.0);\n\n  // // // Animated RGB in [0,1]\n  // const double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5)) * flicker;\n  // const double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0)) * flicker;\n  // const double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0)) * flicker;\n  // gz::math::Color newColor(r, g, b, 1.0);\n\n  // Animated RGB in [0,1]\n  const double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5));\n  const double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0));\n  const double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0));\n  gz::math::Color newColor(r, g, b, 1.0);\n\n\n\n  for (const Entity e : this-&gt;lightEntites)\n  {\n\n    //read data of Light\n    auto lightComp = _ecm.Component&lt;components::Light&gt;(e);\n    if (!lightComp)\n      continue;\n\n    const sdf::v14::Light &amp;sdfLight = lightComp-&gt;Data();\n\n    //convert sdf light msg to gz light msg\n    gz::msgs::Light msg = gz::sim::convert&lt;gz::msgs::Light&gt;(sdfLight);\n\n    //using Set() to set the fields of light msg\n    gz::msgs::Set(msg.mutable_diffuse(),  newColor);\n    gz::msgs::Set(msg.mutable_specular(), newColor);\n\n    //method1\n    // auto cmdComp = _ecm.Component&lt;components::LightCmd&gt;(e);\n    // if (!cmdComp)\n    //   _ecm.CreateComponent(e, components::LightCmd(msg));\n    // else\n    // {\n\n    //   cmdComp-&gt;Data() = msg;\n\n\n    // }\n\n    //method2\n    _ecm.SetComponentData&lt;components::LightCmd&gt;(e,msg);\n\n    // in case of light we need to trigger update so that rendering system knows it updated\n    _ecm.SetChanged(e,\n                    components::LightCmd::typeId,\n                    ComponentState::PeriodicChange);\n                    /// PeriodicChange -&gt;changing periodically,ok to drop few samples\n  }\n}\n\n// Register the plugin\nGZ_ADD_PLUGIN(\n    LightControl,\n    gz::sim::System,\n    LightControl::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(LightControl, \"gz::sim::LightControl\")\n</code></pre>"},{"location":"light-control-system-plugin/#flicker-effect-disco-effect","title":"flicker Effect (Disco effect)","text":"<p>making light intensity low/light give the disco effect</p> <pre><code>//Un comment to see the flicker effect\n// Flicker (no RNG): irregular brightness 0.15..1.0\nconstexpr double kTwoPi = 6.283185307179586;\nconst double t = this-&gt;time;\n\ndouble flicker = 0.55\n  + 0.25 * std::sin(kTwoPi * 17.0 * t)\n  + 0.15 * std::sin(kTwoPi * 23.0 * t + 1.7)\n  + 0.10 * std::sin(kTwoPi * 31.0 * t + 0.3);\n\n\nflicker = std::clamp(flicker, 0.15, 1.0);\n\n// // Animated RGB in [0,1]\nconst double r = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5)) * flicker;\nconst double g = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 2.0)) * flicker;\nconst double b = 0.5 * (1.0 + std::sin(this-&gt;time * 0.5 + 4.0)) * flicker;\ngz::math::Color newColor(r, g, b, 1.0);\n</code></pre>"},{"location":"light-control-system-plugin/#other-way-possible-using-light-class-doesnt-work-as-expected-why","title":"Other Way Possible Using Light Class Doesn't work As Expected Why?","text":"<pre><code>auto lightObj = Light(e);\nlightObj.SetDiffuseColor(_ecm, newColor); \nlightObj.SetSpecularColor(_ecm, newColor);\n</code></pre> <p>if gazebo sim github Light.cc actual code you will understand why</p> actual api code <pre><code>void Light::SetDiffuseColor(EntityComponentManager &amp;_ecm,\n   const math::Color &amp;_color)\n{\n  auto lightCmd =\n    _ecm.Component&lt;components::LightCmd&gt;(this-&gt;dataPtr-&gt;id);\n\n  msgs::Light lightMsg;   ///problem is here it created a entire new msg\n  msgs::Set(lightMsg.mutable_diffuse(), _color);\n  if (!lightCmd)\n  {\n    _ecm.CreateComponent(\n        this-&gt;dataPtr-&gt;id,\n        components::LightCmd(lightMsg));\n  }\n  else\n  {\n    lightCmd-&gt;Data() = lightMsg;\n  }\n}\n</code></pre> <pre><code>void Light::SetSpecularColor(EntityComponentManager &amp;_ecm,\n   const math::Color &amp;_color)\n{\n  auto lightCmd =\n    _ecm.Component&lt;components::LightCmd&gt;(this-&gt;dataPtr-&gt;id);\n\n  msgs::Light lightMsg; ///problem is here it created a entire new msg\n  msgs::Set(lightMsg.mutable_specular(), _color);\n  if (!lightCmd)\n  {\n    _ecm.CreateComponent(\n        this-&gt;dataPtr-&gt;id,\n        components::LightCmd(lightMsg));\n  }\n  else\n  {\n    lightCmd-&gt;Data() = lightMsg;\n  }\n}\n</code></pre> <p><code>msgs::Light lightMsg;</code>   problem is here it created a entire new msg means new light because of which we can change our light certain color property rather end up making new light so be very carefull using direct class of <code>model,world,light</code> etc</p>"},{"location":"move-model-direct-ros-plugin/","title":"MoveModelDirectRos Plugin","text":"<p>As we understood in the last method that ros-gz-brige has limited supported msgs. So we are going undertand to add direct ros2 rclcpp into gazebo sim system plugin.</p> <p>rclcpp we can direct use standard ros2 <code>publisher/subscriber</code>,<code>service/client</code> rclcpp everything of a ros2 node syntex is same.</p>"},{"location":"move-model-direct-ros-plugin/#need-a-different-thread-for-ros2-in-plugin-why","title":"Need A Different thread for ros2 in plugin why?","text":"<p>ros executor code snap</p> <pre><code>rclcpp::executors::SingleThreadedExecutor executor;\nexecutor.add_node(node);\nexecutor.spin();  // blocks this thread, one callback at a time\n</code></pre> <p></p> <p></p> <p>image beautifully display how ros executors work. For example 2 msg are received from topic than ros executors send one method to ros subscriber callback waits for it to process that is the time when it block main thread &amp; once processed sends next msg.</p> <p></p> <p><code>executor.spin()</code> blocking loop until the node shuts down, centralizing event handling for subscriptions, timers, and services within a thread. </p> <p>that means using executor.spin() on gazebo sim will also get blocked(stop for some time) or become unsmooth</p> <p></p> <p> </p>"},{"location":"move-model-direct-ros-plugin/#add-new-thread-for-ros_executor","title":"Add New Thread For ros_executor","text":"<p>so simple solution is make another thread for ros2 using <code>std::thread()</code></p> <p></p> <p>ros spin work with blocking but not harming gz main thread as it a different thread</p> <p>everthing of ros run on the new thread (name: cpp_thread) means <code>OnRosMsg(...)</code> subscriber callback is also part of new thread</p> <p> </p>"},{"location":"move-model-direct-ros-plugin/#code","title":"Code","text":"<p>create the ros2 node &amp; create singe threaded executor. More on ros2 executors <pre><code>  // Create the ROS 2 node\n  this-&gt;ros_node_ = std::make_shared&lt;rclcpp::Node&gt;(\"gz_sim_move_model_plugin\");\n  //   this-&gt;executor_ = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;();\n  this-&gt;ros_executor_ = std::make_shared&lt;rclcpp::executors::SingleThreadedExecutor&gt;();\n  this-&gt;ros_executor_-&gt;add_node(this-&gt;ros_node_);\n</code></pre></p> <p></p> <p>lamda function contain <code>ros_executor-&gt;spin()</code> std::thread() used for creating the new thread</p> <pre><code>  //lamda function having ros spin\n  auto ros_thread_spin = [this]() \n  { \n    this-&gt;ros_executor_-&gt;spin(); \n  };\n\n  //make a new thread for ros spin\n  this-&gt;cpp_thread = std::thread(ros_thread_spin);\n</code></pre> .hh file <pre><code>#ifndef SYSTEM_MOVE_MODEL_DIRECTROS_PLUGIN_MODEL_HH_\n#define SYSTEM_MOVE_MODEL_DIRECTROS_PLUGIN_MODEL_HH_\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/math/Vector3.hh&gt;\n\n// ROS 2 Includes\n#include &lt;rclcpp/rclcpp.hpp&gt;\n#include &lt;std_msgs/msg/float64.hpp&gt;\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n  /// \\brief plugin to move a model\n  /// plugin interface.\n  class MoveModelDirectRos :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    // This class also implements the ISystemPreUpdate interface.\n    public gz::sim::ISystemUpdate\n  {\n   public:\n    MoveModelDirectRos();\n\n    ~MoveModelDirectRos() override;\n\n    void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n    void Update(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\n   private:\n    std::string modelName;\n    std::string rosTopicName;\n    double zVelocity{0.0};\n    Entity targetEntity{kNullEntity};\n    // ROS 2 Members\n    rclcpp::Node::SharedPtr ros_node_;\n    rclcpp::Subscription&lt;std_msgs::msg::Float64&gt;::SharedPtr sub_;\n    // rclcpp::executors::MultiThreadedExecutor::SharedPtr executor_\n    rclcpp::executors::SingleThreadedExecutor::SharedPtr ros_executor_; //Executor to spin the controller\n    std::thread cpp_thread; //std thread to make new thread\n\n\n    /* ROS 2 message callback */\n    /**\n     * @brief ROS 2 callback function for received velocity messages.\n     * @param _msg The shared pointer to the incoming std_msgs/Float64 message.\n    */\n    void OnRosMsg(const std_msgs::msg::Float64::SharedPtr _msg);\n  };\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> .cc file <pre><code>#include \"tutorial_gazebo_plugins/MoveModelDirectRos.hh\"\n\n#include \"gz/sim/Model.hh\"\n#include \"gz/sim/Util.hh\"\n#include \"gz/sim/components/LinearVelocity.hh\"\n#include \"gz/sim/components/LinearVelocityCmd.hh\"\n#include \"gz/sim/components/Name.hh\"\n#include &lt;gz/sim/System.hh&gt;\n#include &lt;gz/plugin/Register.hh&gt;\n\n#include &lt;rclcpp/executors.hpp&gt; // New: ROS 2 includes\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nMoveModelDirectRos::MoveModelDirectRos(){\n  std::cout&lt;&lt;\"MoveModelDirectRos Plugin Started!!\"&lt;&lt;std::endl;\n\n}\nMoveModelDirectRos::~MoveModelDirectRos() {\n  std::cout&lt;&lt;\"MoveModelDirectRos Plugin Stopped!!\"&lt;&lt;std::endl;\n\n}\n\nvoid MoveModelDirectRos::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  // --- Gazebo Sim Configuration ---\n  if (!_sdf-&gt;HasElement(\"model_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;model_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;modelName = _sdf-&gt;Get&lt;std::string&gt;(\"model_name\");\n  gzmsg &lt;&lt; \"Target Model Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n  if (!_sdf-&gt;HasElement(\"ros_topic_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;topic_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;rosTopicName = _sdf-&gt;Get&lt;std::string&gt;(\"ros_topic_name\");\n  gzmsg &lt;&lt; \"Cmd vel Z ROS 2 Topic Name: \" &lt;&lt; this-&gt;rosTopicName &lt;&lt; std::endl;\n\n  if (_sdf-&gt;HasElement(\"z_velocity\"))\n  {\n    this-&gt;zVelocity = _sdf-&gt;Get&lt;double&gt;(\"z_velocity\");\n  }\n  gzmsg &lt;&lt; \"Initial Z Velocity: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; \" m/s\" &lt;&lt; std::endl;\n\n\n  // --- ROS 2 Initialization ---\n  // Initialize ROS 2 (safe to call multiple times)\n  if (!rclcpp::ok())\n  {\n    // Pass in dummy arguments.\n    rclcpp::init(0, nullptr); \n  }\n\n  // ### Explanation ###\n  /*\n\n  ros executor code snap:\n    rclcpp::executors::SingleThreadedExecutor executor;\n    executor.add_node(node);\n    executor.spin();  // blocks this thread, one callback at a time\n\n  gz main thread:\n  ------\n\n  in loop:\n   PreUpdate()     -&gt; using ros spin (executor.spin()) in main thread  will block gazebo sim\n   Update()       \n   PostUpdate()\n\n\n   solution:\n\n   main gz thread                  ---&gt;(make another thread for ros)  using std::thread \n   ------                           |\n                                    |    -&gt; ros spin work with blocking but not harm gz main thread \n  in loop:                          |        as it a different thread\n   PreUpdate()    -&gt; no blocking    |    \n   Update()                         |    -&gt; std::thread -&gt; make new thread cpp_thread having ros_executor-&gt;spin()\n   PostUpdate()                     |  \n\n  */\n\n  // Create the ROS 2 node\n  this-&gt;ros_node_ = std::make_shared&lt;rclcpp::Node&gt;(\"gz_sim_move_model_plugin\");\n//   this-&gt;executor_ = std::make_shared&lt;rclcpp::executors::MultiThreadedExecutor&gt;();\n  this-&gt;ros_executor_ = std::make_shared&lt;rclcpp::executors::SingleThreadedExecutor&gt;();\n  this-&gt;ros_executor_-&gt;add_node(this-&gt;ros_node_);\n\n  //lamda function having ros spin\n  auto ros_thread_spin = [this]() \n  { \n    this-&gt;ros_executor_-&gt;spin(); \n  };\n\n  //make a new thread for ros spin\n  this-&gt;cpp_thread = std::thread(ros_thread_spin);\n\n\n  // Create the ROS 2 subscriber\n  this-&gt;sub_ = this-&gt;ros_node_-&gt;create_subscription&lt;std_msgs::msg::Float64&gt;(\n      this-&gt;rosTopicName, \n      10, // QoS history depth\n      std::bind(&amp;MoveModelDirectRos::OnRosMsg, this, std::placeholders::_1)\n  );\n\n  gzmsg &lt;&lt; \"ROS 2 Subscriber created for topic: \" &lt;&lt; this-&gt;rosTopicName &lt;&lt; std::endl;\n}\n\n\nvoid MoveModelDirectRos::OnRosMsg(const std_msgs::msg::Float64::SharedPtr _msg){\n  // Extract the double value from the ROS 2 Float64 message\n  this-&gt;zVelocity = _msg-&gt;data;\n  gzdbg &lt;&lt; \"Received new Z-velocity command from ROS 2: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; std::endl;\n}\n\nvoid MoveModelDirectRos::Update(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n  // 1. Find the target model entity by name (if not found yet)\n  if (this-&gt;targetEntity == kNullEntity)\n  {\n    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  }\n\n  // 2. Set the Z-axis linear velocity: (0, 0, zVelocity)\n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n\n  // 3. Apply the velocity command component\n  _ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModelDirectRos,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::MoveModelDirectRos,\n                    \"gz::sim::systems::MoveModelDirectRos\")\n</code></pre> <p>every other thing is same as previous MoveModel Using ros-gz-birdge</p>"},{"location":"move-model-direct-ros-plugin/#build-ros2-pkg","title":"Build ros2 pkg","text":"<pre><code>cd ros2_ws\ncolcon build --symlink-install\n</code></pre>"},{"location":"move-model-direct-ros-plugin/#run-ros2-pkg","title":"Run ros2 pkg","text":"<pre><code>source install/setup.bash\nros2 launch yt_tutorial_gazebo_ros move_model_direct_ros.launch.py\n</code></pre>"},{"location":"move-model/","title":"Move Model System Plugin","text":"<p>MoveModel.hh</p> .hh file <pre><code>#ifndef SYSTEM_PLUGIN_MODEL_HH_\n#define SYSTEM_PLUGIN_MODEL_HH_\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;  // to inherit system\n#include \"gz/sim/Model.hh\"  // for Model component\n#include \"gz/sim/components/LinearVelocityCmd.hh\" // for LinearVelocityCmd component\n#include \"gz/sim/components/Name.hh\"  // for Name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\n\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n  /// \\brief plugin to move a model\n  /// plugin interface.\n  class MoveModel :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    // This class also implements the ISystemPreUpdate interface.\n    public gz::sim::ISystemPreUpdate\n  {\n   public:\n    MoveModel();\n\n    ~MoveModel() override;\n\n    void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n    void PreUpdate(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\n   private:\n    std::string modelName;\n    double zVelocity{0.0};\n    Entity targetEntity{kNullEntity};\n  };\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> <p>MoveModel.cc</p> .cc file <pre><code>#include \"MoveModel.hh\"\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nMoveModel::MoveModel(){\n  std::cout&lt;&lt;\"MoveModel Plugin Started!!\"&lt;&lt;std::endl;\n}\nMoveModel::~MoveModel(){\n  std::cout&lt;&lt;\"MoveModel Plugin Stopped!!\"&lt;&lt;std::endl;\n}\n\nvoid MoveModel::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  if (!_sdf-&gt;HasElement(\"model_name\"))\n  {\n    gzerr &lt;&lt; \"ApplyZVelocityPlugin requires a &lt;model_name&gt; element.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;modelName = _sdf-&gt;Get&lt;std::string&gt;(\"model_name\");\n  gzmsg &lt;&lt; \"Target Model Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n  // Read the desired Z linear velocity from SDF\n  if (!_sdf-&gt;HasElement(\"z_velocity\"))\n  {\n    gzerr &lt;&lt; \"ApplyZVelocityPlugin requires a &lt;z_velocity&gt; element.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;zVelocity = _sdf-&gt;Get&lt;double&gt;(\"z_velocity\");\n  gzmsg &lt;&lt; \"Desired Z Velocity: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; \" m/s\" &lt;&lt; std::endl;\n}\n\nvoid MoveModel::PreUpdate(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n\n  //1.Find the target model entity by name (if not found yet)\n  if (this-&gt;targetEntity == kNullEntity)\n  {\n    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  }\n\n  //method 1\n  // 2.Get / create LinearVelocity component\n  auto velComp =\n      _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\n\n  if (!velComp)\n  {\n    velComp = _ecm.CreateComponent(this-&gt;targetEntity,\n                                   components::LinearVelocityCmd());\n    // gzmsg &lt;&lt; \"Added LinearVelocity component to model: \"\n    //       &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n  }\n\n  if (!velComp)\n  {\n    gzerr &lt;&lt; \"Failed to create/get LinearVelocity component for model [\"\n          &lt;&lt; this-&gt;modelName &lt;&lt; \"].\" &lt;&lt; std::endl;\n    return;\n  }\n\n  // 3.Set the Z-axis linear velocity: (0, 0, zVelocity)\n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n  velComp-&gt;Data() = vel;\n\n                  /// or\n\n  // method 2\n  //instate of step 2 &amp; 3 directly run     \n  // const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);     \n  // _ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n\n\n\n\n\n\n  // another method of using Model class a rapper around ecs\n  // gz::sim::Model model(this-&gt;targetEntity);\n  // model.SetLinearVel(vel) \u274c no such function exits so can't use it  \\\n  https://gazebosim.org/api/sim/9/classgz_1_1sim_1_1Model.html#a6ef1a8bed2d5fcc912ac23116c73ec76\n  // https://gazebosim.org/api/sim/9/migrationmodelapi.html Yet in TO DO we do not need it even if you understand EntityComponentManager\n\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModel,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::MoveModel,\n                    \"gz::sim::systems::MoveModel\")\n</code></pre> <p>lets understand the only the part of code which are very different from the previous Print Entity System Plugin</p>"},{"location":"move-model/#sdf-point-to-plugin-in-sdf-file","title":"sdf point to plugin in .sdf file","text":"<pre><code>void MoveModel::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n</code></pre> <p><code>_sdf</code> pointing to plugin tags <code>&lt;model_name&gt;..&lt;/model_name&gt;</code>, <code>&lt;z_velocity&gt;...&lt;/z_velocity&gt;</code> .sdf</p> <p></p> <p>sdf api</p> <p><code>HasElement</code> is used to check if it has the element or not <code>get</code> is used here to get the data from the element (tags)</p> <p> </p> <pre><code>{\n  if (!_sdf-&gt;HasElement(\"model_name\"))\n  {\n    gzerr &lt;&lt; \"ApplyZVelocityPlugin requires a &lt;model_name&gt; element.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;modelName = _sdf-&gt;Get&lt;std::string&gt;(\"model_name\");\n  gzmsg &lt;&lt; \"Target Model Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n  // Read the desired Z linear velocity from SDF\n  if (!_sdf-&gt;HasElement(\"z_velocity\"))\n  {\n    gzerr &lt;&lt; \"ApplyZVelocityPlugin requires a &lt;z_velocity&gt; element.\"\n          &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;zVelocity = _sdf-&gt;Get&lt;double&gt;(\"z_velocity\");\n  gzmsg &lt;&lt; \"Desired Z Velocity: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; \" m/s\" &lt;&lt; std::endl;\n}\n</code></pre> <p> </p>"},{"location":"move-model/#find-the-entity","title":"Find the Entity","text":"<p>gz::sim::EntityComponentManager api doc gz::sim::components api doc</p> <p>to find the entity value will use the Name entity</p> <pre><code>  if (this-&gt;targetEntity == kNullEntity)\n  {\n    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  }\n</code></pre> <p></p>"},{"location":"move-model/#send-move-velocity-command-on-z-axis","title":"Send Move velocity command on z axis","text":"<p>to move the model entity will use LinearVelocityCmd component for that will need to add the component</p> <p>there are 2 working methods for it</p> <p>method 1 <pre><code>//method 1\n  // 2.Get / create LinearVelocity component\n  auto velComp =\n      _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\n\n  if (!velComp)\n  {\n    velComp = _ecm.CreateComponent(this-&gt;targetEntity,\n                                   components::LinearVelocityCmd());\n    // gzmsg &lt;&lt; \"Added LinearVelocity component to model: \"\n    //       &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n  }\n\n  if (!velComp)\n  {\n    gzerr &lt;&lt; \"Failed to create/get LinearVelocity component for model [\"\n          &lt;&lt; this-&gt;modelName &lt;&lt; \"].\" &lt;&lt; std::endl;\n    return;\n  }\n\n  // 3.Set the Z-axis linear velocity: (0, 0, zVelocity)\n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n  velComp-&gt;Data() = vel;\n</code></pre></p> <p>method 2 <pre><code>// method 2\n  //instate of step 2 &amp; 3 directly run     \n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);     \n  _ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n</code></pre></p> <p>one non working method <pre><code>  // another method of using Model class a rapper around ecs\n  gz::sim::Model model(this-&gt;targetEntity);\n  model.SetLinearVel(vel) \u274c no such function exits so can't use it \n  // https://gazebosim.org/api/sim/9/classgz_1_1sim_1_1Model.html#a6ef1a8bed2d5fcc912ac23116c73ec76\n  // https://gazebosim.org/api/sim/9/migrationmodelapi.html Yet in TO DO we do not need it even if you understand EntityComponentManager\n</code></pre></p> <p><code>Model</code> class a rapper around ecs gz::sim::Model</p> <p>Yet in TO DO we do not need it even if you understand EntityComponentManager</p> <p>migrationmodelapi</p> <p>Build &amp; RUN way remains same as pervious plugin</p>"},{"location":"movemodel_using-ros-gazebo-bridge/","title":"Move Model Using ROS GZ Bridge","text":"<p>From Now on we are using ros_ws for all of our plugin. This plugin is just copy paste of MoveModelTopicWay into ros_ws &amp; addition is we are using ros_gz_bridge to map ros2 topic with gazebo topic &amp; control the movel model zVelocity. So the same system plugin on addition is ros2 topic.</p> <p></p> <p> </p> <p></p> <p></p> <p></p>"},{"location":"movemodel_using-ros-gazebo-bridge/#ros-gz-bridge-sytax","title":"ros gz bridge sytax","text":"<pre><code>&lt;topic&gt;@&lt;ros_msg_type&gt;@&lt;gz_msg_type&gt;\n</code></pre> <pre><code>/cmd_vel_z@std_msgs/msg/Float64@gz.msgs.Double[\n</code></pre> <p>The ROS message type is followed by an <code>@, [, or ]</code> symbol where:</p> <ul> <li> <p>@ is a bidirectional bridge.</p> </li> <li> <p>[ is a bridge from Gazebo to ROS.</p> </li> <li> <p>] is a bridge from ROS to Gazebo.</p> </li> </ul> <p>it sometime confusing better to use yaml file way</p> <pre><code>- ros_topic_name: /cmd_vel_z\n  gz_topic_name: /cmd_vel_z\n  ros_type_name: std_msgs/msg/Float64\n  gz_type_name: gz.msgs.Double\n  direction: BIDIRECTIONAL\n</code></pre>"},{"location":"movemodel_using-ros-gazebo-bridge/#important","title":"Important:","text":"<p>there are only limited set of msg supported for ros gz brige</p> <p></p> <p>more here details here in the doc list of supported msg</p>"},{"location":"movemodel_using-ros-gazebo-bridge/#plugin","title":"Plugin","text":"ros2 launch python file <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, ExecuteProcess\nfrom launch.substitutions import LaunchConfiguration, FindExecutable\nfrom launch_ros.actions import Node\nfrom launch import LaunchDescription\nfrom launch.actions import SetEnvironmentVariable, IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nimport os\nfrom ament_index_python.packages import get_package_share_directory\nfrom launch.substitutions import PathJoinSubstitution\n\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n\n    plugin_pkg_path = FindPackageShare('tutorial_gazebo_plugins')\n\n    set_plugin_path = SetEnvironmentVariable(\n    'GZ_SIM_SYSTEM_PLUGIN_PATH',\n    PathJoinSubstitution([plugin_pkg_path, 'plugins'])\n    )\n\n    world_path = os.path.join(\n        get_package_share_directory('yt_tutorial_gazebo_ros'),\n        'worlds',\n        'move_model_topic_way.sdf',\n    )\n\n    ros_gz_sim_share = get_package_share_directory('ros_gz_sim')\n\n    gz_sim = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            os.path.join(ros_gz_sim_share, 'launch', 'gz_sim.launch.py')\n        ),\n        launch_arguments={\n            # see next section for -v\n            'gz_args': f'-r -v4 {world_path}',\n        }.items(),\n    )\n\n\n    # gz_to_ros_bridge = Node(\n    #     package='ros_gz_bridge',\n    #     executable='parameter_bridge',\n    #     name='z_velocity_bridge',\n    #     output='screen',\n    #     arguments=[\n    #         'cmd_vel_z@gz.msgs.Double@std_msgs/msg/Float64'\n    #     ],\n    # )\n\n    config_file_path = os.path.join(\n    get_package_share_directory('yt_tutorial_gazebo_ros'),\n    'configs',\n    'model_topic_way_bridge.yaml'\n    )\n\n    gz_to_ros_bridge = Node(\n    package='ros_gz_bridge',\n    executable='parameter_bridge',\n    name='z_velocity_bridge',\n    output='screen',\n    parameters=[{\n        'config_file': config_file_path\n    }],\n)\n\n    return LaunchDescription([set_plugin_path, gz_sim, gz_to_ros_bridge])\n</code></pre> .sdf plugin part <pre><code>&lt;plugin\n    filename=\"MoveModelTopicWay\"\n    name=\"gz::sim::systems::MoveModelTopicWay\"&gt;\n  &lt;model_name&gt;TestCube&lt;/model_name&gt;\n  &lt;topic_name&gt;cmd_vel_z&lt;/topic_name&gt;\n&lt;/plugin&gt;\n</code></pre> .hh file <pre><code>#ifndef SYSTEM_PLUGIN_MODEL_HH_\n#define SYSTEM_PLUGIN_MODEL_HH_\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt; // to inherit system\n#include \"gz/sim/Model.hh\"  // for Model component\n#include \"gz/sim/components/LinearVelocity.hh\" // for linear velocity \n#include \"gz/sim/components/LinearVelocityCmd.hh\" // for LinearVelocityCmd component\n#include \"gz/sim/components/Name.hh\"  // for Name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n#include &lt;gz/msgs/Utility.hh&gt;    //for msg\n\n#include &lt;gz/transport/Node.hh&gt; //for gz transport node\n#include &lt;gz/math/Vector3.hh&gt;\n#include &lt;gz/msgs/double.pb.h&gt; // Include the Double message type\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n  /// \\brief plugin to move a model\n  /// plugin interface.\n  class MoveModelTopicWay :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    // This class also implements the ISystemPreUpdate interface.\n    public gz::sim::ISystemUpdate\n  {\n   public:\n    MoveModelTopicWay();\n\n    ~MoveModelTopicWay() override;\n\n    void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n    void Update(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\n   private:\n    std::string modelName;\n    std::string topicName;\n    double zVelocity{0.0};\n    Entity targetEntity{kNullEntity};\n    gz::transport::Node node; // GZ Transport node\n\n    /* transport msg callback */\n    void OnTransportMsg(const gz::msgs::Double &amp; _msg);\n  };\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> .cc file <pre><code>#include \"MoveModelTopicWay.hh\"\n\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nMoveModelTopicWay::MoveModelTopicWay() {\n  std::cout&lt;&lt;\"MoveModelTopicWay Plugin Started!!\"&lt;&lt;std::endl;\n\n}\nMoveModelTopicWay::~MoveModelTopicWay(){\n  std::cout&lt;&lt;\"MoveModelTopicWay Plugin stopped!!\"&lt;&lt;std::endl;\n\n}\n\nvoid MoveModelTopicWay::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  // 1. Read the target model name from SDF\n  if (!_sdf-&gt;HasElement(\"model_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;model_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;modelName = _sdf-&gt;Get&lt;std::string&gt;(\"model_name\");\n  gzmsg &lt;&lt; \"Target Model Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n  if (!_sdf-&gt;HasElement(\"topic_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;topic_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;topicName = _sdf-&gt;Get&lt;std::string&gt;(\"topic_name\");\n  gzmsg &lt;&lt; \"Cmd vel z Topic Name: \" &lt;&lt; this-&gt;topicName &lt;&lt; std::endl;\n\n  this-&gt;node.Subscribe(this-&gt;topicName, &amp;MoveModelTopicWay::OnTransportMsg, this);\n\n  if (_sdf-&gt;HasElement(\"z_velocity\"))\n  {\n    this-&gt;zVelocity = _sdf-&gt;Get&lt;double&gt;(\"z_velocity\");\n  }\n  gzmsg &lt;&lt; \"Initial Z Velocity: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; \" m/s\" &lt;&lt; std::endl;\n\n\n}\n\nvoid MoveModelTopicWay::OnTransportMsg(const gz::msgs::Double &amp; _msg){\n  // Directly extract the double value from the message\n  this-&gt;zVelocity = _msg.data();\n  gzdbg &lt;&lt; \"Received new Z-velocity command: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; std::endl;\n}\n\nvoid MoveModelTopicWay::Update(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n  // 1. Find the target model entity by name (if not found yet)\n  if (this-&gt;targetEntity == kNullEntity)\n  {\n    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  }\n\n  //method 1\n  // 2.Get / create LinearVelocity component\n  // auto velComp =\n  //     _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\n\n  // if (!velComp)\n  // {\n  //   velComp = _ecm.CreateComponent(this-&gt;targetEntity,\n  //                                  components::LinearVelocityCmd());\n  //   gzmsg &lt;&lt; \"Added LinearVelocity component to model: \"\n  //         &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n  // }\n\n  // if (!velComp)\n  // {\n  //   gzerr &lt;&lt; \"Failed to create/get LinearVelocity component for model [\"\n  //         &lt;&lt; this-&gt;modelName &lt;&lt; \"].\" &lt;&lt; std::endl;\n  //   return;\n  // }\n\n  // // 3.Set the Z-axis linear velocity: (0, 0, zVelocity)\n  // const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n  // velComp-&gt;Data() = vel;\n\n                  /// or\n\n  // method 2\n  //instate of step 2 &amp; 3 directly run     \n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);     \n  _ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModelTopicWay,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::MoveModelTopicWay,\n                    \"gz::sim::systems::MoveModelTopicWay\")\n</code></pre>"},{"location":"movemodel_using-ros-gazebo-bridge/#build-ros2-pkg","title":"Build ros2 pkg","text":"<pre><code>cd ros2_ws\ncolcon build --symlink-install\n</code></pre>"},{"location":"movemodel_using-ros-gazebo-bridge/#run-ros2-pkg","title":"Run ros2 pkg","text":"<pre><code>source install/setup.bash\nros2 launch yt_tutorial_gazebo_ros move_model_topic_way.launch.py\n</code></pre>"},{"location":"movemodel_using_topic/","title":"Move Model Using Topic System Plugin","text":"<p>In these plugin logic &amp; system api are same as Move Model System Plugin &amp; only addition is we are going to use gz sim topic to control the velocity. We will write a gazebo transport node which will subscribe to gazebo sim topic and base on the value will move the model.</p> <p></p> <p> </p> <p>gazebo transport  - publisher/subscriber c++ example - publisher/subscriber python example</p> <p> </p>"},{"location":"movemodel_using_topic/#plugin","title":"Plugin","text":".sdf plugin part <pre><code>&lt;plugin\n    filename=\"MoveModelTopicWay\"\n    name=\"gz::sim::systems::MoveModelTopicWay\"&gt;\n  &lt;model_name&gt;TestCube&lt;/model_name&gt;\n  &lt;topic_name&gt;cmd_vel_z&lt;/topic_name&gt;\n&lt;/plugin&gt;\n</code></pre> .hh file <pre><code>#ifndef SYSTEM_PLUGIN_MODEL_HH_\n#define SYSTEM_PLUGIN_MODEL_HH_\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt; // to inherit system\n#include \"gz/sim/Model.hh\"  // for Model component\n#include \"gz/sim/components/LinearVelocity.hh\" // for linear velocity \n#include \"gz/sim/components/LinearVelocityCmd.hh\" // for LinearVelocityCmd component\n#include \"gz/sim/components/Name.hh\"  // for Name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n#include &lt;gz/msgs/Utility.hh&gt;    //for msg\n\n#include &lt;gz/transport/Node.hh&gt; //for gz transport node\n#include &lt;gz/math/Vector3.hh&gt;\n#include &lt;gz/msgs/double.pb.h&gt; // Include the Double message type\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n  /// \\brief plugin to move a model\n  /// plugin interface.\n  class MoveModelTopicWay :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    // This class also implements the ISystemPreUpdate interface.\n    public gz::sim::ISystemUpdate\n  {\n   public:\n    MoveModelTopicWay();\n\n    ~MoveModelTopicWay() override;\n\n    void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n    void Update(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\n   private:\n    std::string modelName;\n    std::string topicName;\n    double zVelocity{0.0};\n    Entity targetEntity{kNullEntity};\n    gz::transport::Node node; // GZ Transport node\n\n    /* transport msg callback */\n    void OnTransportMsg(const gz::msgs::Double &amp; _msg);\n  };\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> .cc file <pre><code>#include \"MoveModelTopicWay.hh\"\n\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nMoveModelTopicWay::MoveModelTopicWay() {\n  std::cout&lt;&lt;\"MoveModelTopicWay Plugin Started!!\"&lt;&lt;std::endl;\n\n}\nMoveModelTopicWay::~MoveModelTopicWay(){\n  std::cout&lt;&lt;\"MoveModelTopicWay Plugin stopped!!\"&lt;&lt;std::endl;\n\n}\n\nvoid MoveModelTopicWay::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  // 1. Read the target model name from SDF\n  if (!_sdf-&gt;HasElement(\"model_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;model_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n  this-&gt;modelName = _sdf-&gt;Get&lt;std::string&gt;(\"model_name\");\n  gzmsg &lt;&lt; \"Target Model Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n  if (!_sdf-&gt;HasElement(\"topic_name\"))\n  {\n    gzerr &lt;&lt; \"MoveModel plugin requires a &lt;topic_name&gt; element.\" &lt;&lt; std::endl;\n    return;\n  }\n\n  this-&gt;topicName = _sdf-&gt;Get&lt;std::string&gt;(\"topic_name\");\n  gzmsg &lt;&lt; \"Cmd vel z Topic Name: \" &lt;&lt; this-&gt;topicName &lt;&lt; std::endl;\n\n  this-&gt;node.Subscribe(this-&gt;topicName, &amp;MoveModelTopicWay::OnTransportMsg, this);\n\n  if (_sdf-&gt;HasElement(\"z_velocity\"))\n  {\n    this-&gt;zVelocity = _sdf-&gt;Get&lt;double&gt;(\"z_velocity\");\n  }\n  gzmsg &lt;&lt; \"Initial Z Velocity: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; \" m/s\" &lt;&lt; std::endl;\n\n\n}\n\nvoid MoveModelTopicWay::OnTransportMsg(const gz::msgs::Double &amp; _msg){\n  // Directly extract the double value from the message\n  this-&gt;zVelocity = _msg.data();\n  gzdbg &lt;&lt; \"Received new Z-velocity command: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; std::endl;\n}\n\nvoid MoveModelTopicWay::Update(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n  // 1. Find the target model entity by name (if not found yet)\n  if (this-&gt;targetEntity == kNullEntity)\n  {\n    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  }\n\n  //method 1\n  // 2.Get / create LinearVelocity component\n  // auto velComp =\n  //     _ecm.Component&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity);\n\n  // if (!velComp)\n  // {\n  //   velComp = _ecm.CreateComponent(this-&gt;targetEntity,\n  //                                  components::LinearVelocityCmd());\n  //   gzmsg &lt;&lt; \"Added LinearVelocity component to model: \"\n  //         &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n  // }\n\n  // if (!velComp)\n  // {\n  //   gzerr &lt;&lt; \"Failed to create/get LinearVelocity component for model [\"\n  //         &lt;&lt; this-&gt;modelName &lt;&lt; \"].\" &lt;&lt; std::endl;\n  //   return;\n  // }\n\n  // // 3.Set the Z-axis linear velocity: (0, 0, zVelocity)\n  // const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);\n  // velComp-&gt;Data() = vel;\n\n                  /// or\n\n  // method 2\n  //instate of step 2 &amp; 3 directly run     \n  const gz::math::Vector3d vel(0.0, 0.0, this-&gt;zVelocity);     \n  _ecm.SetComponentData&lt;components::LinearVelocityCmd&gt;(this-&gt;targetEntity,{vel});\n\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModelTopicWay,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::MoveModelTopicWay,\n                    \"gz::sim::systems::MoveModelTopicWay\")\n</code></pre>"},{"location":"movemodel_using_topic/#gazebo-messages","title":"Gazebo Messages","text":"<p>gz-msgs github</p> <p>gz-msgs use google Protobuf messages</p> <p></p> <p>gz msgs Double Class Reference</p> <p></p>"},{"location":"movemodel_using_topic/#gazebo-transport-node","title":"Gazebo Transport Node","text":"<p>transport class api</p> <p></p> <pre><code> gz::transport::Node node; // GZ Transport node\n</code></pre> <p></p> <pre><code>this-&gt;node.Subscribe(this-&gt;topicName, &amp;MoveModelTopicWay::OnTransportMsg, this);\n</code></pre> <p>topic callback function</p> <pre><code>void MoveModelTopicWay::OnTransportMsg(const gz::msgs::Double &amp; _msg){\n  // Directly extract the double value from the message\n  this-&gt;zVelocity = _msg.data();\n  gzdbg &lt;&lt; \"Received new Z-velocity command: \" &lt;&lt; this-&gt;zVelocity &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"movemodel_using_topic/#gazebo-tools-command-line","title":"Gazebo tools (command line)","text":"<p>list topic <pre><code>gz topic -l\n</code></pre></p> <p>check topic msg type <pre><code>gz topic -i -t /cmd_vel_z\n</code></pre></p> <p>send msg <pre><code>gz topic -t /cmd_vel_z -m gz.msgs.Double -p 'data: -1.5'\n</code></pre></p>"},{"location":"print-entity-system-plugin/","title":"Print Entity System Plugin","text":"<p>PrintEntitySystemPlugin.hh</p> .hh file <pre><code>#ifndef SYSTEM_PLUGIN_MODEL_HH_\n#define SYSTEM_PLUGIN_MODEL_HH_\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;  // to inherit system\n#include \"gz/sim/Model.hh\"  // for Model component\n#include \"gz/sim/components/LinearVelocity.hh\" // for linear velocity \n#include \"gz/sim/components/LinearVelocityCmd.hh\" // for LinearVelocityCmd component\n#include \"gz/sim/components/Name.hh\"  // for Name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n\n\n\nnamespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n  /// \\brief plugin to move a model\n  /// plugin interface.\n  class MoveModel :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    // This class also implements the ISystemPreUpdate interface.\n    public gz::sim::ISystemPreUpdate\n  {\n   public:\n    MoveModel();\n\n    ~MoveModel() override;\n\n    void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\n    void PreUpdate(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\n   private:\n    std::string modelName;\n    double zVelocity{0.0};\n    Entity targetEntity{kNullEntity};\n  };\n}\n}\n}\n\n//! [header]\n\n#endif\n</code></pre> <p>PrintEntitySystemPlugin.cc</p> .cc file <pre><code>#include \"PrintEntitySystemPlugin.hh\"\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n\nPrintEntitySystemPlugin::PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin Started!!\"&lt;&lt;std::endl;\n}\nPrintEntitySystemPlugin::~PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin stopped!!\"&lt;&lt;std::endl;\n}\nvoid PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n{\n  this-&gt;targetEntity = _entity;\n  auto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\n  this-&gt;modelName = Name-&gt;Data();\n\n  gzmsg &lt;&lt; \"Target Entity value: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n  gzmsg &lt;&lt; \"Target Entity Name: \" &lt;&lt; this-&gt;modelName &lt;&lt; std::endl;\n\n\n}\n\nvoid PrintEntitySystemPlugin::PreUpdate(const UpdateInfo &amp;_info,\n                          EntityComponentManager &amp;_ecm)\n{\n  // Only run if the simulation is not paused\n  if (_info.paused)\n    return;\n\n\n}\n\n// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n\nGZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre> <p>lets understand code line by line</p>"},{"location":"print-entity-system-plugin/#hh-file-explanation","title":".hh file Explanation","text":"<p>include header files </p> <pre><code>#ifndef WORLD_PLUGIN_HH\n#define WORLD_PLUGIN_HH\n\n//! [header]\n#include &lt;gz/sim/System.hh&gt;   //to inherit system\n#include \"gz/sim/components/Name.hh\" // for name component\n#include &lt;gz/plugin/Register.hh&gt; //for GZ_ADD_PLUGIN_ALIAS()\n</code></pre> <p> all plugin are in gz::sim:::systems namespace <pre><code>namespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n/// \\brief plugin to move a model\n/// plugin interface.\nclass PrintEntitySystemPlugin :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    public gz::sim::ISystemPreUpdate\n{\npublic:\n    PrintEntitySystemPlugin();\n\n    ~PrintEntitySystemPlugin() override;\n\n    void Configure(const Entity &amp;_entity,\n                const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                EntityComponentManager &amp;_ecm,\n                EventManager &amp;_eventMgr) override;\n\n    void PreUpdate(const UpdateInfo &amp;_info,\n                EntityComponentManager &amp;_ecm) override;\n\nprivate:\n    std::string modelName;\n    Entity targetEntity;\n};\n}\n}\n}\n</code></pre></p> <p>PrintEntitySystemPlugin &lt;- inherits   - <code>gz::sim::System</code> :  needed for all system plugins   - <code>`gz::sim::ISystemConfigure</code>: needed for accesing sdf,entity   - <code>gz::sim::ISystemPreUpdate</code>: we are just reading data so even PostUpdate can be used but it not doing anything here. </p> <p>as we know from previous understanding as we inherit <code>ISystemConfigure</code> we need to write defination of <code>Configure()</code> function   &amp; same way <code>ISystemPreUpdate</code> we nee to write defination of <code>PreUpdate(..)</code> function</p> <p> </p>"},{"location":"print-entity-system-plugin/#cc-file-explanation","title":".cc file Explanation","text":"<p>same gz::sim:::systems namespace are added </p> <pre><code>#include \"PrintEntitySystemPlugin.hh\"\n\n\nusing namespace gz;\nusing namespace sim;\nusing namespace systems;\n</code></pre> <p>prints added on constructor &amp; destructor </p> <p><pre><code>PrintEntitySystemPlugin::PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin Started!!\"&lt;&lt;std::endl;\n}\nPrintEntitySystemPlugin::~PrintEntitySystemPlugin(){\n  std::cout&lt;&lt;\"PrintEntitySystemPlugin Plugin stopped!!\"&lt;&lt;std::endl;\n}\n</code></pre> </p> <p>main code is</p> <p><code>_entity</code> is the entity it attached to <code>world,model,light</code> etc </p> <pre><code>void PrintEntitySystemPlugin::Configure(const Entity &amp;_entity,\n    const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n    EntityComponentManager &amp;_ecm,\n    EventManager &amp;/*_eventMgr*/)\n</code></pre> <p></p> <p><pre><code>&lt;world&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;&gt;\n\n&lt;/world&gt;\n</code></pre> so here <code>_entity</code> is world entity</p> <p> </p> <pre><code>&lt;world&gt;\n\n  &lt;model&gt;\n\n    &lt;plugin&gt;  &lt;/&lt;plugin&gt;\n  &lt;/model&gt;\n\n&lt;/world&gt;\n</code></pre> <p>here it <code>_entity</code> is model entity</p> <p> means find the value of the Name Component attached to targetEntity </p> <pre><code>auto Name = _ecm.Component&lt;components::Name&gt;(this-&gt;targetEntity);\nthis-&gt;modelName = Name-&gt;Data();\n</code></pre> <p></p> <p></p> <p><code>Name-&gt;Data()</code>  why?  <code>-&gt;Data()</code> because its comes from <code>component class</code>  return type of <code>_ecm.Component&lt;..&gt;</code> is <code>component</code></p> <p>gz::sim::components::component in gz doc</p> <p></p> <p>need register the plugin with all the class it inhertited  <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::PrintEntitySystemPlugin,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre></p> <p>alias <pre><code>GZ_ADD_PLUGIN_ALIAS(gz::sim::systems::PrintEntitySystemPlugin,\n                    \"gz::sim::systems::PrintEntitySystemPlugin\")\n</code></pre></p> <p>Important: only name=<code>gz::sim::systems::PrintEntitySystemPlugin</code> allowed for plugin you can't put any other name because it how we define on the alis <code>GZ_ADD_PLUGIN_ALIAS(...)</code></p> <p>so </p> <pre><code>&lt;!-- custom plugin attach to world--&gt;\n&lt;plugin\n    filename=\"PrintEntitySystemPlugin\"\n    name=\"gz::sim::systems::PrintEntitySystemPlugin\"&gt;\n&lt;/plugin&gt;\n</code></pre> <p><code>filename= PrintEntitySystemPlugin</code> </p> <p>or </p> <p><code>filename= libPrintEntitySystemPlugin.so</code> </p> <p>so no other name is allowed</p> <p>comes from CMakeList.txt</p> <pre><code>add_library(PrintEntitySystemPlugin SHARED PrintEntitySystemPlugin.cc)\nset_property(TARGET PrintEntitySystemPlugin PROPERTY CXX_STANDARD 17)\ntarget_link_libraries(PrintEntitySystemPlugin\n  PUBLIC gz-plugin${GZ_PLUGIN_VER}::gz-plugin${GZ_PLUGIN_VER}\n  PUBLIC gz-sim${GZ_SIM_VER}::gz-sim${GZ_SIM_VER})\n</code></pre>"},{"location":"some_cplus_concept/","title":"Some C++ Concepts","text":""},{"location":"some_cplus_concept/#1namespace-in-c","title":"1.Namespace in C++","text":"<pre><code>#include &lt;iostream&gt;\n\nnamespace name_1{\n    namespace name_2{\n        int x;\n        void my_fn(){\n            std::cout&lt;&lt;\"hi\"&lt;&lt;std::endl;\n        }\n    }\n}\n\n\nint main() {\n\n    //access\n    name_1::name_2::x = 1;\n    name_1::name_2::my_fn();\n\n    return 0;\n\n}\n</code></pre> <p>similar you will a lot find in gazebo sim codes</p> <pre><code>namespace gz\n{\nnamespace sim\n{\nnamespace systems\n{\n\n\n.....\n\n}\n}\n}\n\n//access outside\ngz::sim::systems xyz; //means its inside gz , sim , systems namespace\n</code></pre> <p>so line like these <code>gz::transport::Node node;</code> means node in gz , transport namespace</p> <p>also means in the doc its under  <code>gz -&gt; transport</code> in the gazebo sim transport api doc </p> <p> </p>"},{"location":"some_cplus_concept/#2stdoptional","title":"2.std::optional","text":"<p>The term std::option refers to the std::optional class template in C++, which is used to represent a value that <code>may or may not be present.</code></p> <pre><code>std::optional&lt;std::string&gt; maybe_name = \"Alice\";\n\nif (maybe_name.has_value()) {  //has_value()\n    std::cout &lt;&lt; \"Name is: \" &lt;&lt; maybe_name.value() &lt;&lt; std::endl;  //value()\n}\n</code></pre> <p>so similarly in gazebo sim api also api example</p> <p></p> <pre><code>    auto entityOpt = _ecm.EntityByName(this-&gt;modelName);\n    if (!entityOpt.has_value())\n    {\n      gzdbg &lt;&lt; \"Model [\" &lt;&lt; this-&gt;modelName\n            &lt;&lt; \"] not found yet. Skipping velocity application.\" &lt;&lt; std::endl;\n      return;\n    }\n\n    this-&gt;targetEntity = entityOpt.value();\n    gzmsg &lt;&lt; \"Found target model entity: \" &lt;&lt; this-&gt;targetEntity &lt;&lt; std::endl;\n</code></pre> <p> </p>"},{"location":"some_cplus_concept/#3this-pointer","title":"3.this pointer","text":"<pre><code>#include &lt;iostream&gt;\n\nclass person{\n  private:\n    int id;\n\n  public:\n   person(int id){\n     this-&gt;id = id;  // access data member\n                     // to avoid confusion id = id  \n   }\n\n   int show_id(){\n      return this-&gt;id; \n   }\n\n   void print_data(){\n       std::cout&lt;&lt; this-&gt;show_id() &lt;&lt; std::endl;  // accessing member funtion\n   }\n};\n\n\nint main() {\n    person a = person(5);\n    a.print_data();\n    return 0;\n}\n</code></pre> <p>similary, on plugin code many time we use this pointer </p>"},{"location":"system-plugin-interfaces/","title":"System Plugin Intefaces","text":"<p>official gazebo sim doc link</p> <p>comman line in any system plugin</p> <pre><code>class MoveModel :\n    // This class is a system.\n    public gz::sim::System,\n    public gz::sim::ISystemConfigure,\n    public gz::sim::ISystemPreUpdate,\n    //public gz::sim::ISystemUpdate,\n    //public gz::sim::ISystemPostUpdate\n</code></pre> <pre><code>// Register the plugin with Gazebo Sim\nGZ_ADD_PLUGIN(gz::sim::systems::MoveModel,\n              gz::sim::System,\n              gz::sim::ISystemConfigure,\n              gz::sim::ISystemPreUpdate)\n</code></pre> <p><code>Note:</code> in inheriting which class what function needs to be defined</p> <ul> <li><code>gz::sim::ISystemConfigure</code>  -&gt; <code>Configure()</code></li> <li><code>gz::sim::ISystemPreUpdate</code>  -&gt; <code>PreUpdate()</code></li> <li><code>public gz::sim::ISystemUpdate</code>  -&gt; <code>Update()</code></li> <li><code>public gz::sim::ISystemPostUpdate</code>  -&gt; <code>PostUpdate()</code></li> </ul> <p> </p> <pre><code>void Configure(const Entity &amp;_entity,\n                   const std::shared_ptr&lt;const sdf::Element&gt; &amp;_sdf,\n                   EntityComponentManager &amp;_ecm,\n                   EventManager &amp;_eventMgr) override;\n\nvoid PreUpdate(const UpdateInfo &amp;_info,\n                  EntityComponentManager &amp;_ecm) override;\n\nvoid Update(const UpdateInfo &amp;_info, EntityComponentManager &amp;_ecm) override;\n\nvoid PostUpdate(const UpdateInfo &amp;_info, const EntityComponentManager &amp;_ecm) override;  \n</code></pre> <p></p> <p>class api: ISystemConfigure,ISystemPreUpdate,ISystemUpdate, ISystemPostUpdate</p> <p>all of the above are pure virtual funtion because of which all need to defined in the derive class</p>"},{"location":"system-plugin-interfaces/#decide-on-interfaces-to-implement","title":"Decide on interfaces to implement","text":"<p>The first step of implementing a system plugin is to determine the subset of available interfaces to implement. Aside from the base System object, there are currently four additional available interfaces:</p> <p></p> <ol> <li>ISystemConfigure<ul> <li><code>read-write access</code></li> <li><code>Executed once</code></li> <li><code>SDF file</code> parameters define </li> </ul> </li> <li>ISystemPreUpdate<ul> <li><code>read-write access</code></li> <li><code>modify state before physics runs</code> </li> </ul> </li> <li>ISystemUpdate<ul> <li><code>read-write access</code> </li> <li>Used for <code>physics simulation step</code> (i.e., simulates what happens at time gz::sim::UpdateInfo::simTime). </li> </ul> </li> <li>ISystemPostUpdate<ul> <li><code>read-only access</code> </li> <li>Used to <code>read out results at the end of a simulation</code> step to be used for <code>sensor or controller updates</code>. </li> </ul> </li> <li>ISystemReset<ul> <li><code>read-write  access</code></li> <li><code>Executed once the moment the plugin is reseted.</code></li> </ul> </li> </ol>"},{"location":"what-is-ecs/","title":"Enitity Component System","text":""},{"location":"what-is-ecs/#what-is-ecs","title":"What Is ECS?","text":""},{"location":"what-is-ecs/#how-ecs-is-fast","title":"How ECS Is Fast?","text":"<p>let understand what is the actual problem &amp; how ecs solve it</p> <p><code>Modern CPUs are insanely fast at math but painfully slow at memory access</code></p> Operation Approx latency CPU register ~1 cycle L1 cache ~4 cycles L2 cache ~12 cycles L3 cache ~40 cycles RAM 200\u2013400 cycles \u274c <p>because RAM is slow cpu used cache for storing small data to process. </p> <p>But the problem with OOPS in traditional Object-Oriented Programming (OOP), you organize code by Objects.</p> <p>eg:</p> <pre><code>class model {\n    std::string modelName;     // owns heap memory (dynamic memory)\n    std::vector&lt;double&gt; pose;  // owns heap memory (dynamic memory)\n    float size[3];             // inline\n    float scale[3];            // inline\n};\n\n/* \n   modelObj is contiguous in memory.\n   However, std::string and std::vector store their data on the heap,\n   causing pointer indirection and non-contiguous access patterns,\n   which reduces cache efficiency in tight loops.\n*/\nmodel modelObj[2]; \n</code></pre> <p></p> <p>but modelName &amp; pose are discontinuous memory because of these it cause trouble to caching <code>The core problem is CPU cache inefficiency caused by memory layout</code></p> <p> </p>"},{"location":"what-is-ecs/#ecs-continuous-memory","title":"ECS Continuous Memory","text":"<p>ECS we just control components &amp; read/write on them one by one</p> <p></p> <p>First loop on modelName components, than loop on all Pose components Because of component now continuous memory is allocated</p> <p></p> <p></p>"}]}